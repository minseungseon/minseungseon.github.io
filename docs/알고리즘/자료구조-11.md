---
layout: default
title: 신장트리, Kruskal, Prim  
parent: 자료구조
grand_parent: 알고리즘
nav_order: 11

---

## 신장트리(spanning tree)
- 그래프의 간선들로만 구성됨
- 모드 정점 포함!  
- 부분 그래프 중에서 모든 정점을 포함하는 트리를 의미한다!  
- n개의 정점을 가지는 그래프의 신장트리는 n-1개의 간선을 가진다!  
- **최소의 링크**를 사용하는 네트워크 구축시에 사용된다. ex. 통신망, 도로망, 유통망  
- DFS 또는 BFS 도중에 사용된 간선만 모으게 되면, 신장트리가 된다!  


## 최소비용 신장트리  
- MST : minimum spanning tree  
- 최저의 비용을 갖는 신장트리이다.  
- 신장트리중에서 사용된 **간선들의 가중치 함이 최소**인 신장트리이다!  
- 즉, 네트워크 내 모든 정점들을 가장 **적은 수의 간선과 비용**으로 연결해주는 트리이다.  

- 도시들을 모두 연결하면서 **도로의 길이를 최소로**하는 문제가 있을 수 있는 도로 건설 분야에서도 응용 될 수 있고, 단자들을 모두 연결하고 그 전선의 길이를 가장 최소로 하는 문제가 있을 수 있는 **전기 회로**분야에서도 활용가능하다. 이 외에도 통신분야의 전화선 길이(전화 케이블 망 구성), 배관(파이프를 모두 연결할 때의 파이프의 총 길이를 최소화 하는 문제) 에 활용 될 수 있다.  

### 신장트리의 제한 조건  


## Kruskal 의 MST 알고리즘, Greedy Method  
- 간단하게 말해서, **최소비용 스패닝트리를 구하는 Kruskal의 알고리즘**이다.  
- Kruskal 외에도 **Prim** 알고리즘도 있다.  
- 주요 알고리즘 설계 기법으로서, 각 단계에서 최선의 답은 선택하는 과정을 반속하여 최종적인 해답에 도달하는 알고리즘이다. 이 때 이러한 greedy method 가 항상 최적의 해답을 준다는 것은 보장이 안된 부분이기 때문에, 이 부분에 대해서는 검증이 필요하다. 또한 한번 내려진 결정에 대해서는 **번복이 불가**하기 때문에 각각의 결정이 가능한 해를 도출해낼 수 있는지 확인해야한다.  
- Kruskal이 20분만에 발견한 알고리즘이어서, 굉장히 직관적인 알고리즘이다!  

- spanning tree(간선트리)이기 때문에 사이클을 포함하지 않고, 최소 비용의 간선으로 구성되어있다.  
- 이 알고리즘에서는 각 단계에서 사이클을 **이루지 않는 최소 비용 간선**을 선택하는데, 이 때 그래프의 간선들을 **가중치의 오름차순으로 정렬**하게 된다. 그리고 그렇게 정렬된 간성 중에서 **사이클을 형성하지 않는 간선**을 현재의 **MST집합에 추가**한다.  

- pesudo code :
```c
//가중치 그래프 G=(V,E)
//n은 노드의 개수이다
//출력되는 것은, 최소비용 신장 트리를 이루는 간선들의 집합인 Et 
Kruskal(G)
    E를 w(e1)<= ... <=w(e) 가 되도록 정렬함 //가중치의 오름차순으로 정렬한다 
    Et <-공집합 값;
    encount <-0

    while encounter<(n-1) do
        k <- k+1
        if Et <-Et 합집합 {ek}가 사이클을 포함하지 않는다면
            then Et <-Et 합집합 {ek}; encounter <- encounter+1

    return

```

## Kruskal MST - union-find 알고리즘  
- 두 집합들의 **합집합**을 만드는 알고리즘이다.  
- 원소가 어떤 집합에 속하는지 알아낸다  
- 어떤 집합에 속하는지를 알아내어, 같은 집합의 원소끼리는 사이클이 형성되고, 다른 집합에 속하면 사이클이 형성되지 않음으로서 Kruskal의 MST 알고리즘에서 **사이클 검사**에 사용이 될 수 있다!  

## Kruskal MST 알고리즘 복잡도  
- Kruskal 알고리즘의 복잡도를 결정하는 가장 중요한 요소는 '간선 정렬 시간'이다.  
- 오히려 사이클 테스트 등의 작업은 정렬에 비해 신속하게 수행되는편이다!  


## Prim의 MST 알고리즘(자연어)  
- 시작 정점에서부터 출발하여 신장 트리 집합을 **단계적으로 확장해나간다**  
- 시작 단계에서는 **시작 정점만이** 신장 트리 집합에 포함된다!  
- 앞 단계의 신장 트리 집합에, **인접한 정점** 중에서 최소 비용 간성으로 연결된 정점을 선택해서 신장 트리 집합에 추가하게 된다.  
- 이 과정은 신장 트리 집합이 n-1개의 간선을 가질 때 까지 반복한다!  

pseudo code:
```c 
Prim(G, s):
Vt-{s}; vcounter <-1
while vcounter < n do
    (u,v)는 u는 Vt의 원소이고 and v는 Vt의 원소가 아닌 최저 비용 간선;
    if (그러한 (u,v)가 존재하면) //예외처리
        then Vt <-Vt합집합v; vcounter <- vcounter+1
    else 실패(신장트리 없음) //예외처리
return Vt
```
조금더 구체적인 psuedo code:
```c
Prim(G,s)
    for each (V의 원소인 u) do
        dist[u] <- 무한대
    dist[s] <-0
    우선 순위로 Q에 모든 정점을 삽입한다(우선순위는 dist[]) // dis[]는 현재까지 알려진 신장트리 정점 집합에서 각 정점까지의 거리(distance)를 의미한다. 
    for i<-0 to n-1 do 
        u <- delete_min(Q)
        화면에 u를 출력한다
        for each (u의 인접 정점의 원소인 v)
            if(Q의 원소가 v라면, 그리고(and) weight[u][v] < dis[v]라면,)
            then dist[v] <- weight[u][v]
```

- 주 반복문이 정점의 수 n만큼 반복하고, 내부 반복문이 n번 반복한다! --> O(n^n)의 복잡도를 가지게 된다!  

