
---
layout: default
title: 정렬 
parent: 자료구조
grand_parent: 알고리즘
nav_order: 13

---

## 정렬  
- 물건을 크기 순으로 오름차순이나 내림차순으로 나열하는 것 
- 컴퓨터 공학을 포함한 **모든 과학 기술 분야**에서 가장 기본적이고 중요한 알고리즘 중 하나이다!  
- 특히 **자료 탐색**에 필수적이다!  

- 정렬의 대상: **레코드**라고 부른다! 레코드 속에서 많은 필드가 있을 수 있다. 예를 들어 학생들의 레코드라면, 학번/이름/주소 등의 **필드**가 존재한다. 그리고 정렬의 기준이 되는 것은 **키(key)**라고 부르며, 한 필드는 Key가 되어 정렬이 된다.  

## 정렬 알고리즘 한눈에 보기!!  
1. 단순하지만 **비효율적**인 방법  
- 선택정렬, 삽입정렬, 버블정렬  

2. 복잡하지만 효율적인 방법  
- 합병정렬, 퀵정렬, 기수정렬, 히프정렬 등 

3. 내부 정렬  
- 모든 데이터가 주기억장치에 저장되어진 상태에서 정렬  

4. 외부 정렬  
- 외부기억장치에 대부분의 데이터가 있고 일부만 주 기억장치에 저장된 상태에서 정렬  

## 안정적인 정렬 알고리즘은?  
- 동일한 키 값을 갖는 레코드들의 **상대적인 위치**가 정렬 후에도 바뀌지 않는 것이 중요하다!  

## 01. 합병정렬  
입력파일: 27,10,12,20,15,35,33,44
이 있으면,  
좌 우 4개씩 분할하고, 그 분할 된 것을 2개씩으로 분할하고 하나씩으로 분할하여  
다 분할이 되고 나서는, 합병을 하면서 정렬을 하는 것이다.  

- 재귀호출이 사용된다!  
- pseudo code
```c
if left<right
        mid = (left+right)/2;
        merge_sort(list,left,mid);
        merge_sort(list,mid+1,right);
        merge(list,left,mid,right);
```

## 합병정렬 복잡도 분석  
- 레코드의 크기가 큰 경우에는 시간낭비가 될 수 있다..!  
레코드를 연결리스트로 구성하여 합병정렬하게되면, 링크 인덱스만 변경되어서 데이터의 이동은 무시할 수 있을 정도로 작아진다! --> 이렇게 하면 크기가 큰 레코드를 정렬하더라도 다른 정렬방법보다 효율적이다!  
- 최적, 평균, 최악의 경우 큰 차이없이 O(n*log(n))의 복잡도를 가진다! (크기 n인 리스트를 정확히 균등 분배하기 때문에 log(n)개 패스하고, 각 패스에서 리스트의 모든 레코드n개를 비교하므로 n번의 비교연산이 돌아가서 n*log(n)이 된다! )  


## 퀵정렬 (quick sort)  
- 평균적으로 **가장 빠른 정렬방법** 이다!  
- 분할정복법을 사용한다  
- 리스트 2개의 부분 리스트로 비균등 분할을 하고, 그리고 재귀호출을 이용해 각각의 부분 리스트를 다시 퀵정렬을 한다. 

- 입력된 리스트의 제일 왼쪽은 **피벗**이라고 한다. 그리고 그 리스트를 피벗보다 작은 값과 큰값으로 나누어 그 가운데에 피벗이 삽입된다.  

## 큌정렬 알고리즘(자연어로)  
정렬할 레코드 개수가 2개 이상이면(if left< right ), 그 정렬할 레코드중 피벗(pivot)레코드를 선택한다. 정렬할 레콛 개수가 2개 이상이 아니라면, 즉 한개라면 정렬이 완료되었다고 리턴한다.  

정렬할 레코드들은 피벗의 왼쪽에는 피벗의 키보다 작거나 같은 레코드들을 위치시키고, 오른쪽에는 피벗의 키보다 크거나 같은 레코드들을 위치시키며 정돈한다.    

퀵 정렬을 순환적으로 사용하여서 피벗의 왼쪽과 오른쪽의 레코드들을 서로 독립적으로 정렬시키도록 한다.  

정렬할 key들의 부분 리스트를 list[] 라고 하고, left는 list[]의 제일 왼쪽 레코드의 인덱스, right은 list[]의 제일 오른쪽 레코드의 인덱스라고 했을 때 큌정렬은 다음과 같이 만들어진다. 
quick_sort(list[],left,right):
정렬할 범위가 2개 이상의 데이터이면,       
    partition 함수를 호출하여 피벗을 기준으로 2개의 리스트로 분할한다. 
    partition 함수의 반환값이 피벗의 위치이다.
    (피벗위치에 대해) 
    피벗보다 큰 것들은 오른쪽으로, 작은 것 들은 왼쪽으로 맞교환하여 배치하게 되고, 피벗을 크기에 맞게 그 사이로 이동한 다음 그 피벗 위치를 반환한다.  

    left 에서 피벗 바로 앞 까지를 대상으로 순환호출하게 된다. 이 때 피벗은 제외된다!
    피벗 바로 다음부터 right 까지를 대상으로 순환호출한다, 이 때도 피벗은 제외된다. 

partition(list[],left,right):

low <-left+1 //제일 왼쪽 값 left 다음 값을(+1) low 라고 한다. 
high <- right //제일 오른쪽 값은 high라고 한다. 

list[제일 왼쪽]을 pivot 으로 선택한다
    list[low] >=pivot이 아니면, low를 증가시킨다. 
    list[high] <= pivot이 아니면, hight를 감소시킨다. 
    low < high 이면 list[low]와 list[high]를 교환한다
    low < high 이면 위의 3개 단계를 반복한다 
pivot과 list[high]를 교환한다
피벗의 위치로 high를 반환한다 

## 퀵 정렬의 복잡도  
n*log(n)

## 기수 정렬 (Radix Sort)  
- 퀵정렬보다 좋지만, 메모리를 많이 사용한다!  
- 레코드를 아예 비교하지 않고, **정렬수행**을 한다!  
