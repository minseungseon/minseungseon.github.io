---
layout: default
title: 이진트리의 순회 
parent: 자료구조
grand_parent: 알고리즘
nav_order: 8

---

## 이진 트리의 순회 & 순회방법  
순회(traversal): 이진 트리에 속하는 **모든 노드를 한 번씩 방문하여** 노드가 가진 데이터를 목적에 맞게 처리하는 것을 의미한다!  

부모노드는 자식노드를 아는데, 자식노드는 부모노드를 찾아갈 수 없다.  

### 순회방법
**의미: V-루트 노드 방문 L-왼쪽 서브 트리를 방문 R-오른쪽 서브 트리를 방문  
- 전위 순회(preorder traversal) : **V**-L-R  
    - 자손 노드보다 **루트 노드**를 먼저 방문한다!  
    - 이진트리에 대해서는, 왼쪽 노드를 먼저 방문하는 깊이우선탐색(DFS)순서는 전위 순회 순서와 같다  
- 중위 순회(inorder traversal): L-**V**-R  
    -왼쪽 자손, 루트, 오른쪽 자손 순으로 방문하는 방식이다!  
- 후위 순회(postorder traversal): L-R-**V**  
    - 루트 노드보다 자손을 먼저 방문한다!  

이 세가지는, 이진트리로 많이 구현된다.  
(그 이유는..)  
**이진트리 자체도 순환 방식으로 정의되어있다! (이진트리: 왼쪽 서브트리와 오른쪽 서브트리로 구성된 노드들의 유한 집합)  

### 순회방법 01. 전위순회(V-L-R)알고리즘  
- 트리 전위 순회 알고리즘  
```c 
//유사코드  

preorder(x):

1. if x!=NULL
2.      then print DATA(x);
3.           preorder(LEFT(x));
4.           preorder(RIGHT(x));

``` 

설명: 
1. 노드 x가 NULL이면 더 이상 순환호출을 하지 않는다.  
2. x의 데이터를 출력한다.(x는 루트노드)
3. x의 왼쪽 서브트리를 순환호출하여 방문한다. 
4. x의 오른쪽 서브트리를 순환호출하여 방문한다.  

### 순회방법 02. 중위순회(L-V-R)알고리즘  
- 트리 중위 순회 알고리즘  
```c 
//유사코드  

inorder(x):

1. if x!=NULL
2.      then  inorder(LEFT(x));
3.           print DATA(x);
4.           inorder(RIGHT(x));

``` 

### 순회방법 03. 후위순회(L-R-V)알고리즘  
- 트리 후위 순회 알고리즘  
```c 
//유사코드  

postorder(x):

1. if x!=NULL
2.      then postorder(LEFT(x));
3.           postorder(RIGHT(x));
4.           print DATA(x);

``` 


## 이러한 순환 호출은  
많이 사용하고 있고, 이해하기도 쉽다!  

## 이진 트리의 순회 : 구현방법 ( 반복 이용 )  
스택이 필요하다!!  
스택에 자식 노드를 저장한다, 그리고 그 자식 노드 스택을 꺼내면서 순회하도록 구현한다.  


## 이진 트리의 순회: 레벨 순회  
레벨 순회(level order)는 각 노드를 레벨순으로 방문하는 순회방법이다!  
레벨 순회는 **큐**를 이용하는 순회방법이다!  
이진 트리에 대해서는, (왼쪽 노드를 먼저 방문하는) 너비우선탐색(BFS)순서는 레벨 순회 순서와 같다!  

### 레벨 순회의 알고리즘  
1. 루트 노드를 큐에 삽입한다.  
2. 큐에 있는 노드를 꺼내어 **방문** 한다음, 그 방문한 노드의 **자식 노드들**을 큐에 삽입한다!  
3. 이 동작을 큐가 빌 때까지 계속한다.  


## 트리의 응용: 수식 트리 처리  
수식트리: **산술식**을 트리형태로 표현한 것이다!  
- 비단말노드: 연산자  
- 단말노드: 피연산자  

이런 수식 트리를, 전/중/후위 순회로 읽게되면! 각각 전/중/후위 표기 수식이 되어서 출력된다!  

그림을 통해 이해해보자:  
자료구조-08-01.png

## 트리의 응용: 트리 속의 구성요소들의 개수 구하기  
1. 트리내의 노드 개수  
    - 각각의 서브트리에 대해 순환 호출  
    - 반환되는 값에 1(자기자신)을 더하여 반환한다!!  
    ```c
    int get_node_count(TreeNode *node)
    {
        int count =0;

        if(node != NULL)
            count = 1+ get_node_count(node->left) + get_node_count(node->right);

        return count;
    }

    ```

2. 단말 노드의 개수  
    - 순회 하면서, 왼쪽 자식과 오른쪽 자식이 동시에 0이 되게 되면, 단말 노드라고 판단한다!  
    - 단말 노드일 때에는 1 를 반환  

    ```c  
    int get_leaf_count(TreeNode *node)
    {
        int count = 0;
        if( node != NULL){
            if (node->left == NULL && node-> right == NULL){
                return 1;
            }
            else{
                count = get_leaf_count(node->left) + get_leaf_count(node->right);
            }
        }
        return count;

    }
    ```

## 수식 트리 - 기출문제1  
1. 후위 표기식을 전위 표기식으로 바꾸기!  
제시된 식: A B C * D / + E -  

풀이:  
1. 중위 표기식을 구한다.  
(((B*C)/D)+A)-E  

2. 수식트리를 그린다.  
        -  
       /  \  
      +    E   
    /   \   
   A     /   
        /  \    
       *    D
     /   \
    B     C  

3. 전위 순회 (V-L-R)  
- + A / * B C D E  

