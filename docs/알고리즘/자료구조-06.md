
---
layout: default
title: 다양한 리스트 
parent: 자료구조
grand_parent: 알고리즘
nav_order: 6

---


## 리스트의 정의 (추상데이터 타입 )  
- 객체: n개의 element형으로 구성된 순서있는 모임  
- 연산:
    - insert(list, pos, itme) ::= pos위치에 요소를 추가한다.  
    - insert_last(list, item) ::= 맨끝에 요소를 추가한다  
    - insert_first(list, item) ::= 맨 처음에 요소를 추가한다. 
    - delete(list, pos) ::= pos 위치의 요소 삭제  
    - clear(list) ::= 리스트 요소 모두 삭제  
    - get_entry(list, pos) ::= pos 위치의 요소를 반환
    - get_length(list) ::= 리스트의 길이를 구함  
    - is_empty(list) ::= 리스트가 비었는지 검사  
    - is_full(list) ::= 리스트가 꽉 찼는지 검사  
    - print_list(list) ::= 모든 요소 표시 

## 리스트 구현 방법  
리스트 구현 방법은 **두가지**가 있다!!  
1. 배열을 이용  
    - 구현 간단  
    - 삽입, 삭제 시에 오버헤드 (요소들을 이동시킨다)  
    - 항목의 개수가 **제한**되어있다  
2. **연결리스트** 이용  
    - 복잡하다..ㅠㅠ  
    - 삽입, 삭제는 **효율적**이다!!  
    - 크기가 제한되어있지 않다!!  


## 배열로 구현된 리스트  
- 1차원 배열에 항목들을 **순서대로** 저장  
- 삽입연산: 삽입위치 다음의 항복들을 이동해야한다 (삽입할 위치를 만들기 위해 삽입 위치 다음의 배열들을 오른쪽으로 한칸씩 이동)  

```c
void insert(ArrayListType *L, int pos, element item){
    if(!is_full(L)&&(pos>=0)&&(pos<= L->size)) //리스트가 포화상태가 아니고, item 을 넣고자 하는 위치가 0이상이면서 리스트의 크기를 넘어서지 않는다면
    {
        for (int i=(L->size-1); i>=pos; i--){ //새로운 item 이 들어오는 자리pos 까지 i는 감소된다!
            L->array[i+1]=L->array[i]; //옆으로 옮겨진다 
        }
        L->aray[pos]=item; //item 넣기
        L->size++;
    }
}

- 삭제연산: 삭제위치 다음의 항목들을 이동시켜야 한다! (삭제시키고 그 삭제된 것 기준 왼쪽 배열들을 한칸씩 왼쪽으로 이동)

## 연결 리스트  
    - 하나의 노드가 데이터와 링크로 구성되어있고, 링크가 노드들을 연결한다.  
    - 다음 항목을 가리키는 주소도 같이 저장한다.  
    - 노드: <항목, 주소> 쌍  
    - 노드는 **데이터 필드**와 **링크 필드**로 구성되어있다!  
        - 데이터필드: 리스트의 원소, 즉 데이터 **값**을 저장  
        - 링크필드: 다른 노드의 **주소값**을 저장하는 장소, **포인터**의 역할을 한다.  
    - 메모리 내에서의 노드의 물리적 순서가 리스트의 논리적 순서와 일치할 필요 없다!  

### 연결리스트 장단점  
장점: 삽입, 삭제가 쉬움, 연속된 메모리 공간이 필요 없음, 크기 제한이 없다!!  
단점: 어렵다는 것..  

### 연결 리스트 구조  
- 헤드 포인터: 리스트의 첫번째 노드를 가리키는 변수  
- 노드의 생성: 필요할 때마다 동적 메모리를 생성하고 이용해서 노드를 생성한다!  
    - 운영체제와 소통하며 리스트에서 요구를 하면, 운영체제에 갔다 온 후 동적 생성이 되는 형식..  

### 연결리스트 종류   
1. 단순 연결 리스트 : 헤드포인터 --> NULL  
    - 하나의 링크 필드를 이용해 연결한다
    - 마지막 노드의 링크 값은 NULL
2. 원형 연결 리스트 : 헤드포인터 --> 다시 헤드포인터로 돌아온다.  
3. 이중 연결 리스트 : 헤드포인터 <--> 다른 노드들  


## 1. 단순 연결 리스트  
- 데이터 필드: 데이터 타입 정의
- 링크 필드: 포인터 사용  

```c
//아래는 노드 한개의 틀이다! 

typedef int element; //int는 4바이트!
typedef struct ListNode{
    element data; //4byte 
    struct ListNode *link; //4byte 
} ListNode;
```

- 공백 검사
    어떤 리스트가 공백인지 검사하기 위해서는 --> **헤드 포인터가 Null 인지 검사하면됨!**  
    `ListNode *head = NULL;`
- `head = (ListNode *)malloc(sizeof(ListNode));` 
    : sizeof(ListNode))는 총 8바이트이다!

- 삽입연산 insert_first()  
    맨 처음에 item요소를 추가한다.  
    head는 헤드포인터, value는 새롭게 추가되는 데이터이다!  
    `ListNode* insert_first(ListNode *head, element value);`  
    이처럼, insert_first()는 변경된 헤더 포인터를 반환하게된다!  

- 알고리즘  
    1. 동적 메모리 할당을 통해 새로운 노드 p를 생성  
        `p<-malloc()`  
    2. p->data에 value 저장(삽입하고자 하는 item)  
        `p->data <-value`  
    3. p->link를 현재의 head 값으로 변경한다!  
        `p->link <- head`  
    4. head를 p값으로 변경한다!   
        `head <-p`  
    5. 변경된 헤드 포인터 반환  
        `return head`  

- 삽입연산 insert()  
    연결리스트 **중간에** 새로운 노드를 추가하는 연산이다!  
    삽입후에도 다른 노드들을 이동할 필요가 없다!  
    
    30,40의 데이터를 가지고 있는 노드 사이에 35의 데이터를 가진 노드를 삽입한다는 상황에 대해 생각해보자!
    - list: 연결리스트, pre: 선행노드, value: 추가할 값 이라고 지정을 하면,
    - pre는 20데이터를 가지고 있는 노드이고, value는 35이다.  

    수도코드:
    ```c
    insert(head, pre, value):
    p <- malloc() //새로운 노드를 생성하여 변수 p로 가리킨다 
    p->data <- value // p의 데이터 필드에 30을 저장함 
    p->link <- pre->link //p의 링크 필드가 노드 "40"을 가르키도록 변경한다 
    pre->link <-p //30의 링크필드가 35를 가리키도록 한다 
    return head  //변경된 헤드포인터를 반환해준다 
    ``` 

  

### 2. 원형 연결 리스트   
- 마지막 노드의 링크가 첫번째 노드를 가리키는 리스트이다! NULL 을 가리키면서 끝나는 것이 아니라, 다시 앞의 노드를 가리키는 식!  
- 헤드 포인터가 **마지막 노드** 를 가리키도록 구성하면, 리스트의 처음이나 마지막에 노드를 삽입하는 연산이 단순 연결 리스트에 비하여 용이해진다! 즉, 편의를 위해 맨 끝에 위치하는 노드를 head로 지정을 해두는 것이다.  
- 단순연결리스트에서처럼, 공백상태 및 초기화 상태에서 원형 연결 리스트는 **헤드포인터만 필요하다!**  
- 이중연결리스트에서는 헤드노드까지 필요하다~!~!  

## 원형연결리스트 : 맨앞에 삽입  
- head가 가르키는 것을 '끝'이라고 약속한다! (only for 편의)  

## 원형연결리스트 활용 : 운영체제(OS)  
- round robin 방식 : os의 핵심적인 부분 중 하나인 scheduling 의 대표적인 기법이다!  
    - 프로세스들 사이에 우선순위를 두지 않고, **순서대로 시간단위** 로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘이다!  
    - 여러 응용에 응답시간을 보장하는 실시간 시스템이다!  
    - 풀어 말해서, 컴퓨터 운영을 할 때 그 컴퓨터 자원을 **이용할 수 있는, 사용할 수 있는 기회**를 프로그램 프로세스들에게 **공정하게 부여**하기 위한 방법이다!
    - 각 프로세스에 일정 시간을 할당하고, 그 할당된 시간이 지나면 그 프로세스는 **잠시 보류**를 한 후에, 다른 프로세스에 기회를 주는 식이다! 이렇게 돌아가며 기회를 부여하는 운영방식이 round robin 방식이다!  
    - 따라서, 시간 단위(보통 100ms) 동안 수행을 다 한 프로세스는 **준비큐**의 끝으로 밀려나게 된다.  
     
## 원형연결리스트 활용 : 원형큐  
- 원형큐는 빈공간이 있어야했고, front 와 rear 모두 관리해야했다. 이를 연결 리스트로 관리를 하게 되면 front와 rear대신 head 하나만 관리를 하면 된다는 점에서 편리하다. 또한 리스트에 있는 모든 데이터는 유효하며, 큐 포화 상태가 발생하는 일도 없다! ( 원형 연결리스트는 앞과 뒤가 연결 관리되는 형식이기 때문에)  


### 2. 이중 연결 리스트  
단순 연결 리스트도 그렇고, 이중 연결 리스트 또한 삽입, 삭제 시에 선행노드가 필요하다. 하지만 단순 연결 리스트의 경우에는 선행 노드를 찾기 어렵다는 것이 단점이다.  
이러한 단순 연결리스트의 단점을 보완할 수 있는 것이 이중 연결 리스트이다.  
이중 연결 리스트는, 한 노드가 그 선행 노드, 후속 노드에 대해 '두 개'의 링크를 모두 가지는 리스트를 의미한다. 이러한 이중연결리스트의 장점은, 링크가 양방향이므로 양방향으로 검색이 가능하다는 것이다. 방향이 한 방향만 있는 단순 연결 리스트와는 다른 점이라고 볼 수 있다. 하지만 양방향에 대한 링크 필드가 필요하다 보니 공간을 많이 차지하게 되고, 코드가 복잡해지는 단점을 가진다. 

### 헤더노드  
단순리스트에서는 헤더노드가 없고, 헤드의 포인터만 가진 노드가 존재했다. 하지만 리스트의 길이, 테일까지의 정보를 가지고 있는 헤더노드를 만들어 사용하면 더 편하다.  
```c
typedef struct ListType{
    int size;
    ListNode *head;
    ListNode *tail;
} ListType; 
```
이러한 헤더노드는,  
- 헤더노드와 헤더만 있더라도 리스트의 선언과 초기화가 가능하다.  
- 데이터를 가지지 않으며, 단지 '삽입, 삭제 코드'를 간단하게 할 목적으로 만들어지는 노드이다!  

## 헤더노드의 활용  
- `insert_last` 에서는 헤더노드를 받아와 끝에 노드가 추가 될 때 리스트의 tail과 head의 포인터를 적절히 바꾸어주는데 쓰인다.

### 이중연결리스트에서의 노드  
- 이중연결리스트에서 임의의 노드를 가리키는 포인터를 `p` 라고 한다면, 
` p == p->rlink->llink == p-> llink-> rlink` 
가 성립된다.
이 부분이 잘 이핵 ㅏ안된다...ㅠㅠ   


## 이중연결리스트의 응용: mp3 재생프로그램!!  
한 음악에서, 다음 음악으로 넘어갔다가 또 다시 그 전으로 넘어가는 이러한 형식은 rlink, llink 의 노드 포인터가 있는 이중연결리스트로 구현이 가능한 예시이다!  


