{"0": {
    "doc": 2020.07,
    "title": "20200724",
    "content": "헉.. 벌써 다음주 수요일이 계절 마지막 날이다..!! . 자료구조 남은 강의수.. 10-2 10-3 . 11-1 11-2 11-3 . 12-1 12-2 12-3 . 13-1 13-2 13-3 . 14-1 14-2 . 15-1 15-2 . 오마이갓.. 온라인 강의는 장단점이 참.. 극단적인 것 같다..ㅠㅠ . 이번주 일요일에 컨트리뷰톤 킥오프미팅 1시~3시 하고나서 10강~11강 끝내구.. 월요일에 12~13강, 화요일에 14~15강을 끝내고 수요일에 과제를..해야겠다.. 인행심은 정말 거의 포기 수준 ㅎㅎ 근데 교양이다보니까 ㅠㅠ 너무 바빠서 솔직히 공부하는게 너무 의미없는 것 같다..! 선택과 집중을 하는 3학년을 보내야하는 괴로운 나날… . ",
    "url": "http://localhost:4000/docs/trivias/202007.html#20200724",
    "relUrl": "/docs/trivias/202007.html#20200724"
  },"1": {
    "doc": 2020.07,
    "title": "20200726",
    "content": "컨트리뷰톤 킥오프미팅! . | hotlist=goodfirstbug 를 검색하면 프로젝트에 대한 지식이 없어서 이슈를 많이 찾을 수 있다. | 이슈와 패치의 순환에 대해서 | 오픈소스에 패치를 보낸다는 것은 설득시키는 과정으로 볼 수 있다. | 가장 중요한것 : 협업과 소통.. | 아무리 좋은 패치라고 너무 큰 패치는 리뷰(소통) 할 수 없다 . | 소통하는 법? . | 기본적인 소통 : 뼈대 코드를 구현하고 –&gt; 서브기능 1 구현 -&gt; 서브기능3 구현 | . | git 전략은 Gitflow 기반 | commit은 대문자 동사 시작을 원칙으로 한다! | 모든 PR 및 Commit은 영어로 작성한다. | . https://material-ui.com/ . | 코드 짤 때 참고하기 | npm install dooboo ui 이런식으로 설치해서 쓸 수 있음 | 실제로 한번 돌려보기! | libarary 의존성 주의 | iOS, android, Web에 적용됨. 세개에서 모두 잘 돌아가는지 확인해야함. (stody board 를 활용해 확인할 수 있다) | 명칭 통일: 전체는 두부유아이 팀, 3-4명은 조! . | 기술 스택 . | expo : ui를 쉽게 배포할 수 있게 도와주는 것 | storybook: component 독립단위로 확인할 수 있게 도와주는 것 | 특정 | react-hook 적극적으로 쓰기! | . | git flow . | 참고: https://woowabros.github.io/experience/2017/10/30/baemin-mobile-git-branch-strategy.html | conventional commit : feature 중요, style(code style을 의미함), refactor(코드 리팩토링 하는 경우) | . | 삼성멀티캠퍼스 , 소마 | . ",
    "url": "http://localhost:4000/docs/trivias/202007.html#20200726",
    "relUrl": "/docs/trivias/202007.html#20200726"
  },"2": {
    "doc": 2020.07,
    "title": 2020.07,
    "content": " ",
    "url": "http://localhost:4000/docs/trivias/202007.html",
    "relUrl": "/docs/trivias/202007.html"
  },"3": {
    "doc": "DRF를 배우기위한 Json 기초",
    "title": "Json",
    "content": "-자바스크립트로 만들어짐 -데이터의 송수신을 자바스크립트의 객체로서 수해할 수 있게끔 해주는 가벼운 문자열 데이터 표현식 -대세이다..! . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#json",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#json"
  },"4": {
    "doc": "DRF를 배우기위한 Json 기초",
    "title": "XML",
    "content": "-일종의 데이터 표현식 -데이터 크기가 좀 커서 요즘은 Json 을 더 많이 씀! . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#xml",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#xml"
  },"5": {
    "doc": "DRF를 배우기위한 Json 기초",
    "title": "Json 의 문법 형식",
    "content": "json_example = { \"string_name\": \"something\", \"number_name\": 3, \"null_name\": null, \"bool_name\": true } . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#json-%EC%9D%98-%EB%AC%B8%EB%B2%95-%ED%98%95%EC%8B%9D",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#json-의-문법-형식"
  },"6": {
    "doc": "DRF를 배우기위한 Json 기초",
    "title": "Json 표현하기",
    "content": "{ \"id\":3, \"title\": \"민승.github.io\", \"body\": \"블로그의 내용입니다\" } . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#json-%ED%91%9C%ED%98%84%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#json-표현하기"
  },"7": {
    "doc": "DRF를 배우기위한 Json 기초",
    "title": "Json 을 Universal 한 언어로 바꾸기",
    "content": "모두가 아는 자료형 인, 문자열 로 변환하여 전송해야함 =”직렬화_seriazlizing” 이라고 함. 따라서, 웹사이트에서도 DRF server 로 ‘문자열을 객체로 바꾸어 보내고’, DRF에서는 ‘객체를 문자열로 바꾸어 보낸’다. =직렬화, 역직렬화 . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#json-%EC%9D%84-universal-%ED%95%9C-%EC%96%B8%EC%96%B4%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#json-을-universal-한-언어로-바꾸기"
  },"8": {
    "doc": "DRF를 배우기위한 Json 기초",
    "title": "참고하면 좋은 사이트",
    "content": "www.json.org . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#%EC%B0%B8%EA%B3%A0%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%82%AC%EC%9D%B4%ED%8A%B8",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#참고하면-좋은-사이트"
  },"9": {
    "doc": "DRF를 배우기위한 Json 기초",
    "title": "파이썬에서 json 사용 방법",
    "content": "json import 시키기 . impot json #매우간단... 이 때 파이썬 파일 이름을 json.py 로 설정하면 안된다.. 이렇게 하면 json module 을 읽어오지 못하더라구요.. 직렬화, 역직렬화 표현하기 . import json #json 임포트 practice_blog = { \"id\": 1, \"title\": \"연습 블로그 글 제목\", \"body\": \"글에 따른 내용물\", } print(practice_blog) #위에 작성한 내용이 프린트됨 {'id': 1, 'title': '연습 블로그 글 제목', 'body': '글에 따른 내용물'} print(type(practice_blog)) #&lt;class 'dict'&gt; #위에 작성된 것의 '타입'인, 딕셔너리가 프린트 됨 #직렬화 practice_blog_srz = json.dumps(practice_blog) #dumps 를 쓰게 되면, distionary 타입을 ---&gt; json 문자열로 바꾸어줌 print (type(practice_blog_srz)) #&lt;class 'str'&gt; #dumps 처리한 것은 이제 '딕셔너리'가 아닌, '문자열'로 프린트됨. #역직렬화 practice_blog_reverse = json.loads(practice_blog_srz) #문자열로 바뀐 것을 다시 딕셔너리로 바꾸어줌 print(type(practice_blog_reverse)) #&lt;class 'dict'&gt; . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-json-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html#파이썬에서-json-사용-방법"
  },"10": {
    "doc": "DRF를 배우기위한 Json 기초",
    "title": "DRF를 배우기위한 Json 기초",
    "content": " ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EB%A5%BC%20%EB%B0%B0%EC%9A%B0%EA%B8%B0%EC%9C%84%ED%95%9C%20Json%20%EA%B8%B0%EC%B4%88.html"
  },"11": {
    "doc": "Http Method",
    "title": "DRF에서의 Http Method",
    "content": "다 하나하나 외우기까지 할 필요는 없다고 한다.. | Method | Meaning | . | Get | 요청받은 URL의 정보를 검색하여 응답함 | . | Post | 요청된 자원을 생성함 | . | Put | 요청된 자원을 수정함 | . | Delete | 요청된 자원을 삭제함 | . | Patch | 요청된 자원의 일부를 교체(수정)함 | . | Option | 웹서버에서 지원되는 메소드의 종류를 확인함 | . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EC%97%90%EC%84%9C%EC%9D%98%20Http%20Method.html#drf%EC%97%90%EC%84%9C%EC%9D%98-http-method",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EC%97%90%EC%84%9C%EC%9D%98%20Http%20Method.html#drf에서의-http-method"
  },"12": {
    "doc": "Http Method",
    "title": "쉬운 예시",
    "content": "Get . 글의 목록을 가져달라는 명령어! . Post . minseung.github.io/post 새 글을 작성 하게 해주는 명령어! . 예를 들어.. minseung.hithub.io/post/1 에 대해서 . | GET 요청이 들어왔다면 -&gt; 1번 글을 가져오라는 요청이 됨 . | DELETE 요청이 들어오면 -&gt; 1번 글을 지워달라는 요청이 됨 . | PUT(PATCH) 요청이 들어오면 1번 글에 이런 내용을 수정해달라는 요청이 됨 . | POST는 필요가 없음 작성이 이미 된 글에 대해서는 새로운 글을 작성하는 요청을 주는 POST 는 의미가 없음. | . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EC%97%90%EC%84%9C%EC%9D%98%20Http%20Method.html#%EC%89%AC%EC%9A%B4-%EC%98%88%EC%8B%9C",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EC%97%90%EC%84%9C%EC%9D%98%20Http%20Method.html#쉬운-예시"
  },"13": {
    "doc": "Http Method",
    "title": "Http Method",
    "content": " ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/DRF%EC%97%90%EC%84%9C%EC%9D%98%20Http%20Method.html",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/DRF%EC%97%90%EC%84%9C%EC%9D%98%20Http%20Method.html"
  },"14": {
    "doc": "HTTPie의 개념",
    "title": "Httpie란,",
    "content": "Command Line으로 작동하는 Http Client . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/HTTPie%EC%9D%98%20%EA%B0%9C%EB%85%90.html#httpie%EB%9E%80",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/HTTPie%EC%9D%98%20%EA%B0%9C%EB%85%90.html#httpie란"
  },"15": {
    "doc": "HTTPie의 개념",
    "title": "Httpie 설치",
    "content": "$ pip install --upgrade httpie #맥 터미널에서는.. $ brew install httpie #홈페이지를 보니 거의 모든 tool로 install 이 가능하다! #https://httpie.org/doc#installation . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/HTTPie%EC%9D%98%20%EA%B0%9C%EB%85%90.html#httpie-%EC%84%A4%EC%B9%98",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/HTTPie%EC%9D%98%20%EA%B0%9C%EB%85%90.html#httpie-설치"
  },"16": {
    "doc": "HTTPie의 개념",
    "title": "Httpie 명령어",
    "content": "http 키워드로 시작함!!! . http [flags_옵션] [METHOD_예를들어 POST] URL [ITEM[ITEM]] . | [ITEM[ITEM]] : 옵션 을 입력하는 곳 | POST,PUT 방식 요청 : ** = **으로 표현 | GET 방식 요청 : ** == **으로 표현 . | Json형식의 요청: http --json POST 대상주소 GET인자 == 값 POST인자 =값 . | HTML form 형식의 요청: http --form POST 대상주소 GET인자==값 POST인자=값 . | Get인자가 있으면 쓰고, 없으면 안써도됨! | Put인자도 마찬가지. | . | . 잘 이해가 되지 않으니 직접 해보도록 하자 . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/HTTPie%EC%9D%98%20%EA%B0%9C%EB%85%90.html#httpie-%EB%AA%85%EB%A0%B9%EC%96%B4",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/HTTPie%EC%9D%98%20%EA%B0%9C%EB%85%90.html#httpie-명령어"
  },"17": {
    "doc": "HTTPie의 개념",
    "title": "직접 해보기",
    "content": "맥이라면, $ brew install httpie 를 하여 설치를 하면 된다! 설치후에 $ http 를 터미널에 치면, 아래와 같이 나온다. [터미널]&lt;img src=./http.png&gt; . $ http get 아무페이지의주소 를 치게 되면 그 페이지에 대한 다양한 정보를 얻을 수 있다. 정말 신기방기 &lt;img src=./http02.png&gt; . | port 번호로 http 명령어를 사용하고 싶으면 $ http :8000 . 이런식으로 터미널에 작성하여야 한다. | http 실험 웹에서 post 요청 해보기 $ http --form post \"httpbin.org/post\" x=1 y=\"hello\" . 이런식으로 form 에 x,y값을 post로 요청하면, 이렇게 확인할 수 있다. | . –form 이 아닌, –json 으로 하면 json에 값이 들어가진다! . | https://httpie.org/ 에서 모든 trial 은 가능하다! | . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/HTTPie%EC%9D%98%20%EA%B0%9C%EB%85%90.html#%EC%A7%81%EC%A0%91-%ED%95%B4%EB%B3%B4%EA%B8%B0",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/HTTPie%EC%9D%98%20%EA%B0%9C%EB%85%90.html#직접-해보기"
  },"18": {
    "doc": "HTTPie의 개념",
    "title": "HTTPie의 개념",
    "content": " ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/HTTPie%EC%9D%98%20%EA%B0%9C%EB%85%90.html",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/HTTPie%EC%9D%98%20%EA%B0%9C%EB%85%90.html"
  },"19": {
    "doc": "Web Backend",
    "title": "Web Backend",
    "content": ":pencil2: 웹 서버단 공부 기록장입니다. ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend.html",
    "relUrl": "/docs/Web_Backend/Web_Backend.html"
  },"20": {
    "doc": "Backend Basics",
    "title": "Backend Basics",
    "content": "백엔드 기초에 대한 기록 . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/Web_Backend_Basics.html",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/Web_Backend_Basics.html"
  },"21": {
    "doc": "알고리즘",
    "title": "알고리즘",
    "content": "java study progress . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/algorithm-menu.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/algorithm-menu.html"
  },"22": {
    "doc": "GIS 데이터 활용",
    "title": "CDIC 공모전 준비",
    "content": "CDIC 공모전을 준비하면서, 활용할만한 공공데이터를 분석해보았다.. ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#cdic-%EA%B3%B5%EB%AA%A8%EC%A0%84-%EC%A4%80%EB%B9%84",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#cdic-공모전-준비"
  },"23": {
    "doc": "GIS 데이터 활용",
    "title": "01 토지특성정보서비스 API",
    "content": "사이트 . ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#01-%ED%86%A0%EC%A7%80%ED%8A%B9%EC%84%B1%EC%A0%95%EB%B3%B4%EC%84%9C%EB%B9%84%EC%8A%A4-api",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#01-토지특성정보서비스-api"
  },"24": {
    "doc": "GIS 데이터 활용",
    "title": "서버..",
    "content": "은행은 자기 서버를 구축하기도함… . 서버는 이제 가상의 개념.. 로컬호스트 장고에서 8000 같은것도 자기 컴퓨터가 서버가 되는 것이다. 8000 서버를 띄웠을 때, . ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#%EC%84%9C%EB%B2%84",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#서버"
  },"25": {
    "doc": "GIS 데이터 활용",
    "title": "서버란",
    "content": "request가 들어오면 response 를 보내주는게 서버이다 서빙하는 웨이터와 같은 역할을 해서 서버이다… . ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#%EC%84%9C%EB%B2%84%EB%9E%80",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#서버란"
  },"26": {
    "doc": "GIS 데이터 활용",
    "title": "서버의 종류",
    "content": "Database WAS(Weg Application Server) - django Nginx(파일을 저장하는데, 무거운 데이터들이 있을 때 쉽게빠르게 가져오기 위해 ‘캐싱’을 한다. 캐싱: 직접 파일 접근이 아니라, 파일의 위치로 접근하는것이다, 계층을 둬서 다 읽을 필요없음, static file 에 대한 로딩을 해줌. 특정 IP에서 공격이 들어오는데 이런것도 무시하도록 해주기도 함(white list), 과부하가 걸리지 않도록 데이터베이스를 여러개 두었을 때 나누도록 해주는 기능을 함(reverse proxy) 정말 실무용 서버! / Apache HTTP . ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#%EC%84%9C%EB%B2%84%EC%9D%98-%EC%A2%85%EB%A5%98",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#서버의-종류"
  },"27": {
    "doc": "GIS 데이터 활용",
    "title": "database",
    "content": ". | 간단하게 각종 데이터를 더 잘 관리하기 위해 만든 시스템 | 예전에는 텍스트 파일로 데이터를 관리함. 복구도 어렵고 이런 문제들을 해결하기 위해서 만들어진 것이 database | 표 형태로 만든것 ( RDMBS ) | NoSQL : 빠르게 확장할 수 있는 DB (좋아요 같은 것과 같이 빠르게 저장하고 빠르게 데이터를 가져오는 것) | Reqest를 주면 저장된 데이터 기반으로 Response 원하는 데이터를 준다. | . ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#database",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#database"
  },"28": {
    "doc": "GIS 데이터 활용",
    "title": "protocol (프로토콜)",
    "content": ". | 사람들이 통신하기 위해 만든 규약 | 우리가 편지쓰는 것과 같이 ‘ 양식 ‘ 을 만드는 것. | request, response 의 양식이 바로 프로토콜인 것이다. | HTTP 가 일종의 프로토콜임. (Cors, Csrf) :웹에서의 대표적인 프로토콜 . | GET, PUT, DELETE, POST 가 있음. | | . | . ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#protocol-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#protocol-프로토콜"
  },"29": {
    "doc": "GIS 데이터 활용",
    "title": "인프라",
    "content": ". | AWS, GCP이런것들이 예전에 없었음. 그래서 물리적인 서버가 필요했다. 서버의 습도..등도 확인해야했다 ㅎ… 원래는 이런것이 인프라의 개념 | 하지만 지금은 물리적인 서버가 거의 없음. 현재의 EC | CICD : 예전에는 개발을 하고 나서 배포를 하려고 할 때 복잡했다. database가 잘 연결됐는지, 등을 확인하는것. 서버 버전도 관리해주고. product manager 가 하는 일이 되었음. | . ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#%EC%9D%B8%ED%94%84%EB%9D%BC",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#인프라"
  },"30": {
    "doc": "GIS 데이터 활용",
    "title": "소프트웨어 공학… 분야..",
    "content": "-확장성, 재사용성 등을 위해 아키텍트(구조)를 설계해야함 . ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B3%B5%ED%95%99-%EB%B6%84%EC%95%BC",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#소프트웨어-공학-분야"
  },"31": {
    "doc": "GIS 데이터 활용",
    "title": "엘리 챗봇",
    "content": ". | ec2 instance 위에 두가지 (챗봇 서버, 어드민 서버) | maria db 를 사용함 (mysql와 비슷하지만, 라이선스 돈을 안내서) | dialogflow api 을 통해 챗봇 서버를 | iOS app 은 챗봇 서버와만 연락을 한다. | 챗봇 뷰도 서버에서 보여주는 것이다(ssr server side rendering) | react는 client side rendering 이다. | admin server : db와만 통신을 함 | 쿼리 : request | 쿼리를 어떻게 짜느냐에 그 데이터 속도가 다라짐 | 쿼리를 튜닝하기도 함 ( 더 성능좋게 인덱스를 넣기도 하고… ) | 쿼리셋 : 하나의 api임. | . 처음으로 데이터베이스를 만드는거는 rds local에 mysql 만들어서 거기에 데이터베이스를 만들어도 됨 . ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#%EC%97%98%EB%A6%AC-%EC%B1%97%EB%B4%87",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html#엘리-챗봇"
  },"32": {
    "doc": "GIS 데이터 활용",
    "title": "GIS 데이터 활용",
    "content": " ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-01.html"
  },"33": {
    "doc": "CDIC",
    "title": "CDIC",
    "content": " ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-menu.html",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/2020%20CDIC/cdic-menu.html"
  },"34": {
    "doc": "Home",
    "title": " :raised_hands: Hi, it's a nice day to dig in more codes! :raised_hands: ",
    "content": ". ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"35": {
    "doc": "Home",
    "title": ":seedling: iOS developer",
    "content": "글로벌 iOS 개발자를 꿈꾸고 있는 선민승입니다 :D . | Github: https://github.com/minseungseon/ | Instagram: @for_xuexi | Email: seonminseung@naver.com | . ",
    "url": "http://localhost:4000/#seedling-ios-developer",
    "relUrl": "/#seedling-ios-developer"
  },"36": {
    "doc": "Home",
    "title": ":pushpin: 함께 일하기 좋은 iOS 개발자가 되기 위해 노력합니다.",
    "content": ". | storyboard를 활용하여 iOS 프로젝트를 진행한 경험과 오직 programmatically iOS 개발을 진행한 경험 모두 있습니다. | github을 통해 iOS 프로젝트를 서버담당자와, 웹담당자와 함께 협업한 경험이 있습니다. | 더 나은 아키텍쳐를 가진 앱을 만들기 위해 고민해보았습니다. | . ",
    "url": "http://localhost:4000/#pushpin-%ED%95%A8%EA%BB%98-%EC%9D%BC%ED%95%98%EA%B8%B0-%EC%A2%8B%EC%9D%80-ios-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%B4-%EB%85%B8%EB%A0%A5%ED%95%A9%EB%8B%88%EB%8B%A4",
    "relUrl": "/#pushpin-함께-일하기-좋은-ios-개발자가-되기-위해-노력합니다"
  },"37": {
    "doc": "Home",
    "title": ":sparkles: 다양한 분야에서의 경험을 갖춘 개발자입니다.",
    "content": ". | 명덕외국어고등학교 중국어과를 졸업하여 중앙대학교 영어교육학과 18학번으로 입학해, 2년간의 영어교육학 공부를 했습니다. | 높은 수준의 영어 회화,작문,독해 능력을 갖추고 있으며 간단한 중국어 회화 및 독해를 할 수 있습니다. | 2020년에 중앙대학교 소프트웨어학과로 3학년 전과를 하여 깊은 CS 지식을 쌓아나가고 있습니다. | 다양한 도전과 활동을 통해 웹 프런트,벡엔드의 경험이 있으며 2020년 부터 iOS 개발자의 진로를 정하여 꾸준히 노력하고 있습니다. | AI/딥러닝 관련 교육을 수료한 경험이 있습니다. (한국인공지능아카데미 딥러닝 음성챗봇 교육, 한국인공지능아카데미 파이썬으로 챗봇 만들기 교육, 2019 양재혁신허브 AI SCHOOL 비전공자를 위한 인공지능 입문과정(케라스 코리아)) | . ",
    "url": "http://localhost:4000/#sparkles-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%B6%84%EC%95%BC%EC%97%90%EC%84%9C%EC%9D%98-%EA%B2%BD%ED%97%98%EC%9D%84-%EA%B0%96%EC%B6%98-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9E%85%EB%8B%88%EB%8B%A4",
    "relUrl": "/#sparkles-다양한-분야에서의-경험을-갖춘-개발자입니다"
  },"38": {
    "doc": "Home",
    "title": ":herb: 소통의 경험이 있는 개발자입니다.",
    "content": ". | 중앙대학교 멋쟁이 사자처럼 6기 수료 후, 7기(2019), 8기(2020) 운영진으로서 python django 웹 교육을 비전공자/전공자를 대상 멘토링을 진행했습니다. | 교환학생과 한국인의 교류를 위한 동아리, EXCHANGE NEWBIE를 만들어 약 50명의 외국인과 100명의 한국인 회원들과 2년간 활동했으며, 이를 위한 ruby on rails 기반의 웹을 기획해 웹개발을 한 경험이 있습니다. | . ",
    "url": "http://localhost:4000/#herb-%EC%86%8C%ED%86%B5%EC%9D%98-%EA%B2%BD%ED%97%98%EC%9D%B4-%EC%9E%88%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9E%85%EB%8B%88%EB%8B%A4",
    "relUrl": "/#herb-소통의-경험이-있는-개발자입니다"
  },"39": {
    "doc": "Home",
    "title": ":deciduous_tree: 꾸준히 공부하는 개발자입니다.",
    "content": ". | Apple Korea iOS 앱 개발 교육(중앙대 내)을 수료했습니다. | udacity iOS developer nano degree course 수료 중에 있습니다. | 꾸준한 알고리즘 스터디를 통해 CS 지식을 복습하고 공부합니다. | . ",
    "url": "http://localhost:4000/#deciduous_tree-%EA%BE%B8%EC%A4%80%ED%9E%88-%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9E%85%EB%8B%88%EB%8B%A4",
    "relUrl": "/#deciduous_tree-꾸준히-공부하는-개발자입니다"
  },"40": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"41": {
    "doc": "variables and functions",
    "title": "첫 iOS udacity!",
    "content": "드디어! 첫번째 iOS 강의를 듣게 되었다. 오늘 들은 강의 리스트는 다음과 같다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#%EC%B2%AB-ios-udacity",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#첫-ios-udacity"
  },"42": {
    "doc": "variables and functions",
    "title": "list of lessons for today",
    "content": "| index | topic | . | 1 | variable 작성 연습 | . | 2 | 주석 달기 | . | 3 | text 외에 숫자도 variable 은 담을 수 있다! | . | 4 | swift 안에 있는 data type | . | 5 | 변수의 데이터 타입 정확하게 지정해주기 | . | 6 | 상수 (constant) | . | 7 | 변수 이름짓기 | . | 8 | literal 이란? | . | 9 | Escape Characters | . | 10 | String Interpolation 문자열 삽입 | . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#list-of-lessons-for-today",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#list-of-lessons-for-today"
  },"43": {
    "doc": "variables and functions",
    "title": "variable 작성 연습",
    "content": "var question = \"Ready to write your first lines of Swift code?\" print(question) var response = \"Yes, I am ready!\" print(response) . 위의 두 문장이 출력되게 된다! . 예를 들어, Hello, world! 를 출력하기 위해서는 다음과 같이 작성한다. var welcome = \"Hello, world\" print(welcome) . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#variable-%EC%9E%91%EC%84%B1-%EC%97%B0%EC%8A%B5",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#variable-작성-연습"
  },"44": {
    "doc": "variables and functions",
    "title": "주석 달기",
    "content": "주석은 java와 똑같이 달면 된다!! . | 라인 주석 // 코멘트입니다 . | multi line 주석 /* 여러 라인을 위한 주석입니다*/ . | . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#%EC%A3%BC%EC%84%9D-%EB%8B%AC%EA%B8%B0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#주석-달기"
  },"45": {
    "doc": "variables and functions",
    "title": "text 외에 숫자도 variable 은 담을 수 있다!",
    "content": "var amountToUseToday = 4 . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#text-%EC%99%B8%EC%97%90-%EC%88%AB%EC%9E%90%EB%8F%84-variable-%EC%9D%80-%EB%8B%B4%EC%9D%84-%EC%88%98-%EC%9E%88%EB%8B%A4",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#text-외에-숫자도-variable-은-담을-수-있다"
  },"46": {
    "doc": "variables and functions",
    "title": "swift 안에 있는 data type",
    "content": "swift 에는 다른 언어들과 비슷하게 int, float, double, bool, character, string의 데이터타입이 있다. | int : whole number values (0,2,-2) | float: 32 bit의 floating-point(decimal)numbers that require no more than 6 decimal digits(3.14,5.675,-12.34) | double: 64 bit의 floating-point(decimal) numberst that require more precision(예시는 float과 같음) | bool : a boolean truth value (truth, false 와 같은 것) | character : 글자 한글자 한글자 (“a”, “+”, ) | String : 문자열 (“swift”, 등) | . 이 때, float 과 더블의 차이는 무엇일까? - float 과 double 의 차이는 ‘정확성의 차이’에 있다. - 컴퓨터는 floating-point number를 다루는데에 항상 어려움을 겪는다! - 그리고 보통은 더 정확한 값을 다루기 위해 double 을 사용하는 것이 대부분의 경우이다. - 하지만, 그렇다고 해서 항상 double 이 가장 좋은 것만은 아니다. 속도가 더 중요할 때에는, float를 선택하는 것이 더 나은 선택이 될 수 있다! . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#swift-%EC%95%88%EC%97%90-%EC%9E%88%EB%8A%94-data-type",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#swift-안에-있는-data-type"
  },"47": {
    "doc": "variables and functions",
    "title": "변수의 데이터 타입 정확하게 지정해주기",
    "content": "var myMiddleInitial: Character = \"A\" //이렇게 :datatype 을 써줌으로서 변수의 데이터타입을 지정해준다! . 이렇게 변수타입을 지정해주지 않더라도, swift는 언어의 특성상 ‘변수 타입에 대한 추론’기능이 좋은 편이다. 예를 들어서 . var isThisString = \"Minseung\" . 의 변수에 대해서 자동으로 String data type 으로 인식한다. 하지만 앞의 예서에서의 “A” 와 같은 변수에 대해서는 character 로 바로 인식하지는 못한다. double, bool, string에 대해서는 그 변수의 데이터 타입은 따로 지정해주지 않아도 swift가 잘 인식하는 반면에, character 타입은 String 으로 인식하기 때문에, character 의 경우에는 따로 위에서 언급했듯이 변수지정을 sepecify 해줘야 한다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#%EB%B3%80%EC%88%98%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85-%EC%A0%95%ED%99%95%ED%95%98%EA%B2%8C-%EC%A7%80%EC%A0%95%ED%95%B4%EC%A3%BC%EA%B8%B0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#변수의-데이터-타입-정확하게-지정해주기"
  },"48": {
    "doc": "variables and functions",
    "title": "상수 (constant)",
    "content": "variable(변수)는 다시 그 값이 할당 될 수 있으나, constant(상수)는 값이 변할 수 없다. 변수는 var 로, 상수는 let으로 선언한다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#%EC%83%81%EC%88%98-constant",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#상수-constant"
  },"49": {
    "doc": "variables and functions",
    "title": "변수 이름짓기",
    "content": "정말 신기하게도!!! swift 에서는 이모티콘을 변수이름으로 쓸 수 있게 한다. (물론 드물다고 한다 ㅎ) 안되는 경우의 수는 다음과 같다. 1. 숫자로 시작하는 이름 2. 특별문자로 시작하는 경우 . swift에서는 lowerCamelCase 로 변수 이름을 짓도록 규정하고 있다는 것을 기억하자! . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#%EB%B3%80%EC%88%98-%EC%9D%B4%EB%A6%84%EC%A7%93%EA%B8%B0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#변수-이름짓기"
  },"50": {
    "doc": "variables and functions",
    "title": "literal 이란?",
    "content": "swift 에서는 리터럴을 ‘a literal is the source code representation of a value of a type, such as a number or string’ 이라고 정의한다. 즉, 숫자, 문자열 과 같은 하나의 타입의 값을 literal 이라고 정의하게 된다. 변수 자체는 literal 이 될 수도 있고, 아닐 수도 있는 것이다. 그 변수 속에 담겨있는 숫자와 문자열 값이 바로 literal 을 의미한다. var myNumber = 5 var welcome = \"hello\" var getting = welcome . 위의 코드에서, 5와 hello 는 literal 이지만, welcome 은 literal 이 아니다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#literal-%EC%9D%B4%EB%9E%80",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#literal-이란"
  },"51": {
    "doc": "variables and functions",
    "title": "Escape Characters",
    "content": "String 의 값을 넣을 때에, 띄어쓰기, 탭, “”, ‘’, 또는 backslash의 경우에는 escape character를 통해 표현해줘야한다. | character | usage | . | \\n | newline 새로운 줄로 넘어갈 때 엔터치는 것을 의미함 | . | \\t | horizontal tab 탭을 의미함 | . | \" | 쌍따옴표 double quotation mark | . | ' | single quotation mark | . | \\ | backslash | . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#escape-characters",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#escape-characters"
  },"52": {
    "doc": "variables and functions",
    "title": "String Interpolation 문자열 삽입",
    "content": "\\(variableName) . 을 통해 문자열을 특정 문자열에 삽입할 수 있다!! . var insertThis = \"Minseung\" var insertHere = \"My name is, \\(insertThis)\" print(insertHere) . 출력: My name is, Minseung . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#string-interpolation-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%82%BD%EC%9E%85",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html#string-interpolation-문자열-삽입"
  },"53": {
    "doc": "variables and functions",
    "title": "variables and functions",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-01.html"
  },"54": {
    "doc": "operators",
    "title": "Core Terms",
    "content": "operator 와 관련하여 알아두면 좋은 핵심 영어 용어들을 정리해보았다! . | 영어 단어 | 뜻 | 예시 | . | Operator | 연산자 |   | . | Operand | 연산자(operator)의 영향을 받는 하나의 target, 혹은 value(값)을 의미한다. | 8-5 라는 expression 에서, operator(연산자)는 ‘-‘ 이고, operand는 8과 5이다. 즉, 8-5의 expression 에서는 8과 5 의 operand 에 ‘-‘가 적용이 되었다고 이해한다. | . | Precedence | 우선시 되는 것 | 어떤 연산자가 먼저 계산되는지에 대한 우선권을 의미한다. 더하기보다는 곱하기 연산자를 먼저 계산하는 것이 precedence rule 에 의한 순서 이다. | . | Associativity | 연관성 | left-assosicative 는 더하기 연산자에 해당한다. 왼쪽부터 차례대로 계산한다. right associatvie는 제곱 연산자’^’에 해당하는 것이다. 오른쪽부터 제곱해나간다. | . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-02.html#core-terms",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-02.html#core-terms"
  },"55": {
    "doc": "operators",
    "title": "문자열에 연산자 쓰기",
    "content": "기존의 java 언어 처럼 문자열을 숫자처럼 연산할 수 있다! . var stringConcat = \"my\" var withOperator = \"name\" let myName = stringConcat + \" \" + withOperator . 출력: my name . withOperator += \"!\" . 이렇게 추가하는 것도 가능하다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-02.html#%EB%AC%B8%EC%9E%90%EC%97%B4%EC%97%90-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%93%B0%EA%B8%B0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-02.html#문자열에-연산자-쓰기"
  },"56": {
    "doc": "operators",
    "title": "operators",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-02.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-02.html"
  },"57": {
    "doc": "conditionals",
    "title": "swift 이틀차!",
    "content": "오늘은 소맥을 마시고.. 강의 정리를 해본다.. 취중 코오딩!! swift야.. 사랑했뜨ㅏㅏㅏㅏㅏㅏㅏㅏ~~!!~!~!~!~!~!~ . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#swift-%EC%9D%B4%ED%8B%80%EC%B0%A8",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#swift-이틀차"
  },"58": {
    "doc": "conditionals",
    "title": "예제를 통한 swift 에서의 if문",
    "content": "guestList에 있다면, 환영인사를 보내고! 그렇지 않다면 초대를 거절하는 if 문 예시를 작성해보자! . if onGuestList { print(\"\\(name), welcome!\") } if !onGuestList { print(\"\\(name), sorry but you are not on my guestlist!\") } . 조건이 두개 이상 일 때에는 어떻게 할까? guestList 에 없거나, 21살 보다 어릴 때에는 거절하는 메세지를 띄우도록 해보자! . if (isGuestList &amp;&amp; age&gt;=21) { print(\"\\(name), welcome! you are adequate for this party!!\") } if(!isGuestList || age&lt;21){ print(\\(name), sorry, but you are not over 21, or you are not on my guest list. \") } . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#%EC%98%88%EC%A0%9C%EB%A5%BC-%ED%86%B5%ED%95%9C-swift-%EC%97%90%EC%84%9C%EC%9D%98-if%EB%AC%B8",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#예제를-통한-swift-에서의-if문"
  },"59": {
    "doc": "conditionals",
    "title": "swift 에서의 multiple conditions",
    "content": "swift 에서 조건문을 여러개 만들기 위해서는 어떻게 할까!! java 와 아주 똑같다! 아닌가… 아니다! 조금 다르다 ㅎㅎ swift 에서는 괄호를 안써도 된다! . if isFirstCondition { print(\"이것은 첫번째 조건문이 만족되면 출력됩니다.\") } else if isSecondCondition { print(\"이것은 두번째 조건문이 만족되면 출력됩니다.\") } else if isThirdCondition { print(\"이것은 세번째 조건문이 만족되면 출력됩니다.\") } else { print(\"이것은 모든 조건문이 만족 안된다면 출력됩니다.\") } . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#swift-%EC%97%90%EC%84%9C%EC%9D%98-multiple-conditions",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#swift-에서의-multiple-conditions"
  },"60": {
    "doc": "conditionals",
    "title": "swift 에서의 switch",
    "content": "java 와 정말 똑같다!! . ```switch month { case 1: print(“1월”) case 2: print(“2월”) case 3: print(“3월”) } . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#swift-%EC%97%90%EC%84%9C%EC%9D%98-switch",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#swift-에서의-switch"
  },"61": {
    "doc": "conditionals",
    "title": "swift 에서의 range(범위)",
    "content": "이것은! swift 에서만의 특징이다. 눈여겨 보시길…. 예를 들어, 1,2,3,4,5를 출력하려고 할 때에, 다음과 같이 표현할 수 있다. //첫번째 경우 1...5 //두번째 경우 1..&lt;6 . 위의 두가지 경우 모두 1,2,3,4,5를 의미하게 한다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#swift-%EC%97%90%EC%84%9C%EC%9D%98-range%EB%B2%94%EC%9C%84",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#swift-에서의-range범위"
  },"62": {
    "doc": "conditionals",
    "title": "swift 문에서 i를 이용한 for문",
    "content": "java 에서는 for 문을 보통 int i 를 이용하여 많이 사용한다! 이러한 i 를 iterator(반복자) 라고 부르고, swift 에서는 iterator 를 사용할 수도, 사용하지 않을 수도 있다! . 1. iterator 를 사용하는 경우 . for i in 1...15 { print(i) } . 출력: 123456789101112131415 . 2. iterator 를 사용하지 않는 경우 . for _ in 1..3 { print(\"안녕\") } . 출력: 안녕 안녕 안녕 . 3. 그 외의 경우 . String 의 각각의 character 개수만큼 각각의 character 를 출력하도록 할 수 있다! array (배열) 의 개념을 사용하는 것이다. let word = \"github\" //총 6개의 character 를 가진 문자열 word 를 선언한다! for char in word { print(char) } . 출력: g i t h u b . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#swift-%EB%AC%B8%EC%97%90%EC%84%9C-i%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-for%EB%AC%B8",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#swift-문에서-i를-이용한-for문"
  },"63": {
    "doc": "conditionals",
    "title": "(번외) swift 에서의 랜덤함수",
    "content": "swift 에서의 랜던함수가 for 문을 공부하는데 계속해서 나와서 공유한다… 왜 자꾸 안배운 것을 알려주는걸까.. 이런 코오딩 공부란.. 끝이 없는 것.. 1. arc4random() . | 리턴 타입이 UInt32이다. 즉, 0부터 2^32-1 범위를 가진다. | 즉, 0과 2^32-1 사이의 난수를 반환한다. | . 2. arc4random_uniform(UInt32) . | 파라미터로 UInt32를 받는다! –&gt; 0부터 파라미터로 넣은 UInt32-1 사이의 난수를 리턴한다. | var randomNumber = arc4random_uniform(400)은, 0과 399 사이의 난수를 리턴하게 된다. | . #### 예시 . 0과 1 중에서 랜덤으로 변수에 값을 저장하고 싶으면, . var randomNumber = arc4random_uniform(2) . 이렇게 지정해주면 된다. 3. drand48() . | 0부터 1.0 사이의 난수를 리턴한다. | . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#%EB%B2%88%EC%99%B8-swift-%EC%97%90%EC%84%9C%EC%9D%98-%EB%9E%9C%EB%8D%A4%ED%95%A8%EC%88%98",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#번외-swift-에서의-랜덤함수"
  },"64": {
    "doc": "conditionals",
    "title": "while loop 예시",
    "content": "첫번째 문제 . 0…1000까지의 범위에서 짝수만을 출력하는 swift 문을 작성하라! . var div: Int = 1 //integer type 의 div 를 1로 초기화 한다. while(!(div*2==1002)){ //1002가 되기 전까지 while 문을 돌린다. print(div*2) //div에 2를 곱하여 프린트 한다. div += 1 //곱한 이후에는 div 를 1 씩 증가시킨다. } . 두번째 문제 . 0…500까지의 범위(inclusive, 즉 500을 포함하는 범위)에서 짝수만을 출력하는 swift 문을 작성하라! . var number = 0 while true { number += 2 print(number) if(number == 500){ break } } . 세번째 문제 . 두 코인 모두 뒷면이 나올 때까지 두 코인이 뒷면, 혹은 앞면이 나오는지를 프린트 해라. var tails: Int = 1 var randomNum01: Int var randomNum02: Int while(true){ randomNum01 = Int(arc4random_uniform(2)) randomNum02 = Int(arc4random_uniform(2)) print(\"\\(randomNum01), \\( randomNum02)\") if(randomNum01==tails &amp;&amp; randomNum02==tails){ break; } } . 출력: . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#while-loop-%EC%98%88%EC%8B%9C",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#while-loop-예시"
  },"65": {
    "doc": "conditionals",
    "title": "reapeat-while 문",
    "content": "java, c언어에서의 do-while문 과 같다! . 예시: . var i = 1 repeat { print(\"\\(i)번째 줄입니다!\") i += 1 } while i&lt;10 . 출력: . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#reapeat-while-%EB%AC%B8",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html#reapeat-while-문"
  },"66": {
    "doc": "conditionals",
    "title": "conditionals",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-03.html"
  },"67": {
    "doc": "using functions",
    "title": "iOS 세번째 날!",
    "content": "캡스톤 공모전도 준비를 해야해서 정신이 없다 ㅠㅠ 부모님도 오늘 오랜만에 올라오시공,,, 아이공,,, 공,,, zero,,, 아무래도 오늘은 조금밖에 못할 것 같은 느낌!! . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#ios-%EC%84%B8%EB%B2%88%EC%A7%B8-%EB%82%A0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#ios-세번째-날"
  },"68": {
    "doc": "using functions",
    "title": "list of lessons for today",
    "content": "| index | topic | . | 1 | | . | 2 | | . | 3 | | . | 4 | | . | 5 | | . | 6 | | . | 7 | | . | 8 | | . | 9 | | . | 10 | | . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#list-of-lessons-for-today",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#list-of-lessons-for-today"
  },"69": {
    "doc": "using functions",
    "title": "function 이해하기",
    "content": "예시를 통해 쉽게 이해할 수 있다! . func whatIsFunc() { print(\"Function 은 호출 할 수 있는 하나의 함수입니다!\") } whatIsFunc() //호출 . 출력: . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#function-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#function-이해하기"
  },"70": {
    "doc": "using functions",
    "title": "function signature 란",
    "content": "function 을 선언할 때, addValues(value1: Int, value2: Int) 이 부분을 function signatue 라고 부른다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#function-signature-%EB%9E%80",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#function-signature-란"
  },"71": {
    "doc": "using functions",
    "title": "parameter(매개변수)를 포함한 funcion 사용",
    "content": "단일 매개변수인 경우 . func loveIt(subject: String) { //function 선언 print(\"I love \\(subject)\") } var subjectEx = \"Swift\" //function 의 parameter(매개변수)로 들어갈 subjectEx 변수를 선언 loveIt(subject: subjectEx) //Swift를 문자열 값으로 가지고 있는 변수를 매개변수로 loveIt function 에 넣어주고 호출함 . 출력: . 매개변수가 여러 개인 경우 . func areaOfRectangle(length: Int, width: Int){ //가로와 세로를 int 값으로 가져올 매개변수를 넣어준다. print(\"이 사각형의 넓이는: \" + String(length*width) + \"이다.\") //print를 할 때에는 int 값을 print 가능한 문자열로 바꾸어준다. } areaOfRectangle(length: 20,width: 10) . 출력: 이 사각형의 넓이는: 200이다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#parameter%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EB%A5%BC-%ED%8F%AC%ED%95%A8%ED%95%9C-funcion-%EC%82%AC%EC%9A%A9",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#parameter매개변수를-포함한-funcion-사용"
  },"72": {
    "doc": "using functions",
    "title": "return 값 지정하기",
    "content": "function 의 특징은 바로 return값이 있다는 것이다! return 값을 function 에서 지정해줄 수 있는데, 그 data type 에 대해서 function 을 처음에 선언할 때 언급해야한다. 예를 들어 areaOfTriangle 이라는 func 에서 리턴값을 Double 로 지정하고 싶다면, 아래와 같이 -&gt; Double 을 추가한다. func areaOfTriangle(base: Double, height: Double) -&gt; Double{ return 0.5*base*height } let area: Double area = areaOfTriangle(base: 4, height: 10) print(area) . 출력: 20 . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#return-%EA%B0%92-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#return-값-지정하기"
  },"73": {
    "doc": "using functions",
    "title": "parameter의 default값 지정하기",
    "content": "function에 들어가는 매개변수들이 매번 들어오는 값에 따라 달라지는 것이 아니라, 몇 개의 매개변수중 특정 변수는 기본 값으로 항상 같은 값을 가지도록 하는 것이 필요할 수 있다. 이렇게 하기 위해서는 처음에 매개변수를 선언 할 때에 값을 지정해주면 된다. func endOfYearBonus(basePay: Double, bonus: Double, percentBonus: Double = 0.10 ) -&gt; Double { return basePay+bonus+(basePay * percentBonus) } print(endOfYearBonus(basePay: 10.0, bonus: 10.0)) //percentBonus 지정 하지 않음, 위의 default 값 이용 print(endOfYearBonus(basePay: 10.0, bonus: 10.0, percentBonus: 0)) //위의 deafult 값 override . 출력: 21.0 20.0 . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#parameter%EC%9D%98-default%EA%B0%92-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#parameter의-default값-지정하기"
  },"74": {
    "doc": "using functions",
    "title": "전역 매개변수, 지역 매개변수 (Internal and External Parameter Names)",
    "content": "01 internal parameter name . func addVaolues(value1 x: Int, value2 y: Int) { //이렇게 작성하면 이 function 내에서 x 와 y를 지역변수로 사용하게된다. return x+y } . 02 external parameter name . 전역 매개변수는 기존에 사용하던 대로 하는 방식을 의미하는데, 사실 매번 전역 매개변수를 full name 으로 호출하여 parameter 이름을 넣어주기가 귀찮다. 무슨 말이냐면… . func loveIt(subject: String) { print(\"I love \\(subject)\") } loveIt(subject: \"앞에 매개변수이름인 subject를 매번 써주는 것이 귀찮다는 것이다..!\") . 위 코드에서 언급했듯이, function을 호출하면서 전역 매개변수를 매번 써주고 그 뒤에 입력할 데이터를 넣는 것이란 굉장히 귀찮은 일이다… 그래서 아래와 같이 매개변수를 넣어주면 호출할 때에 매개변수 이름을 넣어줄 필요가 없게된다! . func loveIt(_ subject: String) { print(\"I love \\(subject)\") } loveIt(\"앞에 매개변수이름인 subject를 안써줘도 된당\") //매개변수 이름을 안써줘도 된다! . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#%EC%A0%84%EC%97%AD-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%A7%80%EC%97%AD-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-internal-and-external-parameter-names",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html#전역-매개변수-지역-매개변수-internal-and-external-parameter-names"
  },"75": {
    "doc": "using functions",
    "title": "using functions",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-04.html"
  },"76": {
    "doc": "struct and enums",
    "title": "iOS 3.5일차..!",
    "content": "매 강의를 기록하면서 들으려고 하다보니 기초 부분에서 시간이 굉장히 많이 할애되는 것 같다.. 그래도 결국 기록을 안해놓으면 똥이 되니까.. 기록의 버릇을 들이기 위해 열심히 기록해보겠다 ㅠㅠ 지금 github.io 메인 페이지에도 심지어 아무것도 안써져 있는데 ㅋㅋㅋㅋㅋㅋㅋ 내용만 채워가는 나자신…ㅎㅎ…. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#ios-35%EC%9D%BC%EC%B0%A8",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#ios-35일차"
  },"77": {
    "doc": "struct and enums",
    "title": "list of lessons for today",
    "content": "| index | topic | . | 1 | | . | 2 | | . | 3 | | . | 4 | | . | 5 | | . | 6 | | . | 7 | | . | 8 | | . | 9 | | . | 10 | | . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#list-of-lessons-for-today",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#list-of-lessons-for-today"
  },"78": {
    "doc": "struct and enums",
    "title": "swift에서의 구조체",
    "content": "가장 기본적인 형태는 다음과 같다. struct student { let name: String //프로그램 상에서 학생의 이름이 바뀌는 것을 원하지 않기 때문에 let 을 통해 상수로 선언한다 var age: Int var school: String } . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#swift%EC%97%90%EC%84%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%B2%B4",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#swift에서의-구조체"
  },"79": {
    "doc": "struct and enums",
    "title": "property 란",
    "content": "알아두면 좋은 swift 용어이다. struct(구조체)에서 위에서 보았듯이 ‘학생’이라는 구조체 내에서 ‘이름, 나이, 학교’와 같은 것을 member 혹은 property라고 일컫는다. 이것은 애플에서 사용하는 용어이기 때문에 알아두면 좋다! . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#property-%EB%9E%80",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#property-란"
  },"80": {
    "doc": "struct and enums",
    "title": "언제 initialize(값 초기화)를 해야할까?",
    "content": "이 부분이 항상 헷갈리는 것 같다. java 언어를 배울 때에도 초기화를 언제 해줘야하는건지, mandatory(필수)인 것인지에 대해 굉장히 궁금했다. 해답은 , 변수의 값 초기화는 필수는 아니다 라는 것이다. 하지만, 잘 생각해보면 값이 정해져 있지 않으면 그냥 ‘0’으로 디폴트 값을 주고 계산을 잘 넘겨야하는 경우가 있다. 기본 값이 0으로도 안정해져있으면 null값이 넘어가기 때문에 프로그램 자체가 돌아가지 않을 수 있기 때문이다. 그래서 이러한 경우에는 다음과 같이 디폴트 값을 초기화 해준다. struct GeoLocation { var latitude: Double = 0.0 var longitude: Double = 0.0 } . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#%EC%96%B8%EC%A0%9C-initialize%EA%B0%92-%EC%B4%88%EA%B8%B0%ED%99%94%EB%A5%BC-%ED%95%B4%EC%95%BC%ED%95%A0%EA%B9%8C",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#언제-initialize값-초기화를-해야할까"
  },"81": {
    "doc": "struct and enums",
    "title": "구조체 별 인스턴스 선언하기",
    "content": "구조체만을 만들어서는 아무것도 안된다..! 구조체 별로 인스턴스를 선언하여 구조체를 백분 활용해보자! . struct Movie { let title: String let year: Int } var firstMovie = Movie(title: \"첫번째 영화 제목\", year: 1999) var secondMovie = Movie(title: \"두번째 영화 제목\", year: 2000) print(firstMovie) print(secondMovie) . 출력: Movie(title: \"첫번째 영화 제목\", year: 1999) Movie(title: \"두번째 영화 제목\", year: 2000) . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#%EA%B5%AC%EC%A1%B0%EC%B2%B4-%EB%B3%84-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%84%A0%EC%96%B8%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#구조체-별-인스턴스-선언하기"
  },"82": {
    "doc": "struct and enums",
    "title": "구조체의 인스턴스에 접근하기",
    "content": "인스턴스의 접근은 굉장히 쉽다! java 에서 처럼 구조체.proprety이름 으로 접근하면된다! 예를 들어서, 위의 movie 예시에서 firstMovie의 title 에 접근해서 출력하고 싶으면, . print(firstMovie.title) . 이렇게 접근하면 된다! . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%9D%98-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html#구조체의-인스턴스에-접근하기"
  },"83": {
    "doc": "struct and enums",
    "title": "struct and enums",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/ios-05.html"
  },"84": {
    "doc": "iOS",
    "title": "iOS",
    "content": ":pencil2: iOS 공부 기록장입니다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/iosmenu.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/iosmenu.html"
  },"85": {
    "doc": "do-while문",
    "title": "do-while문",
    "content": "특징: i의 값이 적어도 한번은 출력이 된다는 것이 특징 . 형번환은 무조건 해주어야한다. c = (char)(c+1); c는 character 이고 c+1 은 integer 이기 때문에 (character + 정수형 은 integer) c 값에 (char)(c+1) 을 넣어주려면 형변환 을 해주어야함 . loop 중첩은 3번정도가 제일 바람직함. 너무 복잡해짐! . continue문이 있으면 조건식으로 다시 가게됨 . brake문은 완전히 반복문 하나를 빠져 나가게 함 . scanner.nextline() -&gt; 엔터키를 칠때까지 = 한문장을 가져온다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java01.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java01.html"
  },"86": {
    "doc": "do-while문",
    "title": "trouble-shooting",
    "content": "println() 과 print() 를 헷갈렸다.. println() 은 줄 바꿈을 하지만, print()는 줄을 바꾸지 않고 그냥 출력해주는 명령어이다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java01.html#trouble-shooting",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java01.html#trouble-shooting"
  },"87": {
    "doc": "예제풀이",
    "title": "예제풀이",
    "content": "public class AverageCal { public static void main(String[] args) { AverageCal r = new AverageCal(); int [] intArray = {1,2,3,4,5,6}; double [] dbArray = {6.0, 4.4, 1.9, 2.9, 3.4, 3.5}; System.out.println(average(intArray)); System.out.println(r.average(dbArray)); } public static int average(int [] array) { int i = 0; int avg = 0; for (i=0; i&lt;array.length; i++) { avg += array[i]; } return avg/array.length; //이렇게 하면 되지만 } public double average(double [] array) { double avg = 0.0; int i = 0; for (i=0; i&lt;array.length; i++) { avg += array[i]; avg = avg/array.length; //이렇게 하면 return 이 되지 않는다.. } return avg; } } . 왜그러는걸까..! . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java02.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java02.html"
  },"88": {
    "doc": "인터페이스",
    "title": "인터페이스의 구성 요소",
    "content": ". | 상수 public만 허용하고, public static final 은 생략한다! . | 추상 메소드 public abstract 생략 가능 . | default 메소드 인터페이스에 코드가 작성된 메소드이다. 인터페이스를 구현하는 클래스에 자동 상속된다. | private 메소드 인터페이스 내에 메소드 코드가 작성되어야 한다. 인터페이스 내에 있는 다른 메소드에 의해서만 호출이 가능하다. | static 메소드 public, private 모두 지정 가능 -&gt; 생략하면 public . | . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java03.html#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java03.html#인터페이스의-구성-요소"
  },"89": {
    "doc": "인터페이스",
    "title": "인터페이스를 구현하자!",
    "content": ". | 선언 ``` java interface PhoneInterface { //인터페이스 선언 | . } ``` . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java03.html#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EA%B5%AC%ED%98%84%ED%95%98%EC%9E%90",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java03.html#인터페이스를-구현하자"
  },"90": {
    "doc": "인터페이스",
    "title": "인터페이스",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java03.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java03.html"
  },"91": {
    "doc": "모듈 사용",
    "title": "모듈이란?!",
    "content": ". | java 9에서 도입된 개념 | 클래스들이 포함되어 있는 패키지 들과, 이미지등 리소스를 담은 컨테이너 | . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#%EB%AA%A8%EB%93%88%EC%9D%B4%EB%9E%80",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#모듈이란"
  },"92": {
    "doc": "모듈 사용",
    "title": "JRE",
    "content": "=Java Runtime Environment =자바 실행 환경 . | 자바 모듈(컴파일된 자바 API 클래스들, 예를 들어 scanner 같은 것!), 자바 가상 기계 등으로 구성되어 있다. | Java 9 이후부터는 rt.jar 을 설치할 필요가 없고, 필요한 모듈 및 클래스를 따로 import 하여 JRE 를 개선함 | 예전에는 rt.jar에 모든 자바 api 를 담아두었는데, 이제는 99개의 모듈로 나누어졌다! 자바 모듈화 라고 불린다 | . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#jre",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#jre"
  },"93": {
    "doc": "모듈 사용",
    "title": "Java API에 대한 정보를 알고싶다면..",
    "content": "https://docs.oracle.com/javase/10/docs/api/overview-summary.html . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#java-api%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%95%8C%EA%B3%A0%EC%8B%B6%EB%8B%A4%EB%A9%B4",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#java-api에-대한-정보를-알고싶다면"
  },"94": {
    "doc": "모듈 사용",
    "title": "Object 클래스",
    "content": "-모든 클래스의 수퍼 클래스 -모든 객체가 공통으로 가지는 객체의 속성을 나타내는 메소드를 보유한다. -object 클래스의 주요 메소드 . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#object-%ED%81%B4%EB%9E%98%EC%8A%A4",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#object-클래스"
  },"95": {
    "doc": "모듈 사용",
    "title": "Wrapper 클래스",
    "content": "-클래스 이름이 wrapper가 아님! -byte, short, int, long, char, float, double, boolean 을 앞글자 대문자로 하여 가지는 것을 Wrapper 클래스 라고 함! . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#wrapper-%ED%81%B4%EB%9E%98%EC%8A%A4",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#wrapper-클래스"
  },"96": {
    "doc": "모듈 사용",
    "title": "Wrapper 클래스 객체 생성",
    "content": "-기본 타임의 값으로 객체 생성 . integer i = Integer.valueOf(10); Character c = Character.valueOf('c'); Boolean b = Boolean.valueOf(true); . -문자열로 Wrapper 객체 생성 . integer i = Integer.valueOf(\"10\"); Double d = Double.valueOf(\"3.14\"); Boolean b = Boolean.valueOf(\"false\"); . -Float 객체는 double 타입의 값으로부터 생성 가능 . Float f = Float.valueOf((float) 3.14); . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#wrapper-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#wrapper-클래스-객체-생성"
  },"97": {
    "doc": "모듈 사용",
    "title": "String 객체",
    "content": "-스트링 생성 방법 (리터럴로 생성) . String a = \"hello\"; String b = \"Java\"; String c = \"hello\"; //a 와 c는 동일한 문자열을 참조함 String d = new String(\"hello\"); String e = new String(\"hello\"); //d 와 e는 별로 메모리로 만들어짐 . -스트링 객체는 수정 불가능 한 번 만들어지면, ~.concat 을 통해 두 문자열을 합치더라도 두개의 다른 메모리로 만들어진다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#string-%EA%B0%9D%EC%B2%B4",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#string-객체"
  },"98": {
    "doc": "모듈 사용",
    "title": "문자열 비교",
    "content": "int compareTo(String anotherString) . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B9%84%EA%B5%90",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#문자열-비교"
  },"99": {
    "doc": "모듈 사용",
    "title": "공백제거",
    "content": "String trim() . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#%EA%B3%B5%EB%B0%B1%EC%A0%9C%EA%B1%B0",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#공백제거"
  },"100": {
    "doc": "모듈 사용",
    "title": "StringBuffer 클래스",
    "content": "-가변크기의 문자열 저장 클래스 -String 클래스와 달리 문자열 변경 가능 -StringBuffer 객체의 크기는 스트링 길이에 따라 가변적 . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#stringbuffer-%ED%81%B4%EB%9E%98%EC%8A%A4",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#stringbuffer-클래스"
  },"101": {
    "doc": "모듈 사용",
    "title": "Calendar 객체",
    "content": "-Calendar 객체 생성 Calendar now = Calendar.getInstance(); . ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#calendar-%EA%B0%9D%EC%B2%B4",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html#calendar-객체"
  },"102": {
    "doc": "모듈 사용",
    "title": "모듈 사용",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/java04.html"
  },"103": {
    "doc": "java",
    "title": "java",
    "content": ":pencil2: java 공부 기록장입니다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/javamenu.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/javamenu.html"
  },"104": {
    "doc": "server에 대한 기본 이해",
    "title": "서버..",
    "content": "은행은 자기 서버를 구축하기도함… . 서버는 이제 가상의 개념.. 로컬호스트 장고에서 8000 같은것도 자기 컴퓨터가 서버가 되는 것이다. 8000 서버를 띄웠을 때, . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/server-01.html#%EC%84%9C%EB%B2%84",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/server-01.html#서버"
  },"105": {
    "doc": "server에 대한 기본 이해",
    "title": "서버란",
    "content": "request가 들어오면 response 를 보내주는게 서버이다 서빙하는 웨이터와 같은 역할을 해서 서버이다… . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/server-01.html#%EC%84%9C%EB%B2%84%EB%9E%80",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/server-01.html#서버란"
  },"106": {
    "doc": "server에 대한 기본 이해",
    "title": "서버의 종류",
    "content": "Database WAS(Weg Application Server) - django Nginx(파일을 저장하는데, 무거운 데이터들이 있을 때 쉽게빠르게 가져오기 위해 ‘캐싱’을 한다. 캐싱: 직접 파일 접근이 아니라, 파일의 위치로 접근하는것이다, 계층을 둬서 다 읽을 필요없음, static file 에 대한 로딩을 해줌. 특정 IP에서 공격이 들어오는데 이런것도 무시하도록 해주기도 함(white list), 과부하가 걸리지 않도록 데이터베이스를 여러개 두었을 때 나누도록 해주는 기능을 함(reverse proxy) 정말 실무용 서버! / Apache HTTP . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/server-01.html#%EC%84%9C%EB%B2%84%EC%9D%98-%EC%A2%85%EB%A5%98",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/server-01.html#서버의-종류"
  },"107": {
    "doc": "server에 대한 기본 이해",
    "title": "database",
    "content": ". | 간단하게 각종 데이터를 더 잘 관리하기 위해 만든 시스템 | 예전에는 텍스트 파일로 데이터를 관리함. 복구도 어렵고 이런 문제들을 해결하기 위해서 만들어진 것이 database | 표 형태로 만든것 ( RDMBS ) | NoSQL : 빠르게 확장할 수 있는 DB (좋아요 같은 것과 같이 빠르게 저장하고 빠르게 데이터를 가져오는 것) | Reqest를 주면 저장된 데이터 기반으로 Response 원하는 데이터를 준다. | . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/server-01.html#database",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/server-01.html#database"
  },"108": {
    "doc": "server에 대한 기본 이해",
    "title": "protocol (프로토콜)",
    "content": ". | 사람들이 통신하기 위해 만든 규약 | 우리가 편지쓰는 것과 같이 ‘ 양식 ‘ 을 만드는 것. | request, response 의 양식이 바로 프로토콜인 것이다. | HTTP 가 일종의 프로토콜임. (Cors, Csrf) :웹에서의 대표적인 프로토콜 . | GET, PUT, DELETE, POST 가 있음. | | . | . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/server-01.html#protocol-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/server-01.html#protocol-프로토콜"
  },"109": {
    "doc": "server에 대한 기본 이해",
    "title": "인프라",
    "content": ". | AWS, GCP이런것들이 예전에 없었음. 그래서 물리적인 서버가 필요했다. 서버의 습도..등도 확인해야했다 ㅎ… 원래는 이런것이 인프라의 개념 | 하지만 지금은 물리적인 서버가 거의 없음. 현재의 EC | CICD : 예전에는 개발을 하고 나서 배포를 하려고 할 때 복잡했다. database가 잘 연결됐는지, 등을 확인하는것. 서버 버전도 관리해주고. product manager 가 하는 일이 되었음. | . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/server-01.html#%EC%9D%B8%ED%94%84%EB%9D%BC",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/server-01.html#인프라"
  },"110": {
    "doc": "server에 대한 기본 이해",
    "title": "소프트웨어 공학… 분야..",
    "content": "-확장성, 재사용성 등을 위해 아키텍트(구조)를 설계해야함 . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/server-01.html#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B3%B5%ED%95%99-%EB%B6%84%EC%95%BC",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/server-01.html#소프트웨어-공학-분야"
  },"111": {
    "doc": "server에 대한 기본 이해",
    "title": "엘리 챗봇",
    "content": ". | ec2 instance 위에 두가지 (챗봇 서버, 어드민 서버) | maria db 를 사용함 (mysql와 비슷하지만, 라이선스 돈을 안내서) | dialogflow api 을 통해 챗봇 서버를 | iOS app 은 챗봇 서버와만 연락을 한다. | 챗봇 뷰도 서버에서 보여주는 것이다(ssr server side rendering) | react는 client side rendering 이다. | admin server : db와만 통신을 함 | 쿼리 : request | 쿼리를 어떻게 짜느냐에 그 데이터 속도가 다라짐 | 쿼리를 튜닝하기도 함 ( 더 성능좋게 인덱스를 넣기도 하고… ) | 쿼리셋 : 하나의 api임. | . 처음으로 데이터베이스를 만드는거는 rds local에 mysql 만들어서 거기에 데이터베이스를 만들어도 됨 . ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/server-01.html#%EC%97%98%EB%A6%AC-%EC%B1%97%EB%B4%87",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/server-01.html#엘리-챗봇"
  },"112": {
    "doc": "server에 대한 기본 이해",
    "title": "server에 대한 기본 이해",
    "content": " ",
    "url": "http://localhost:4000/docs/Web_Backend/Web_Backend_Basics/server-01.html",
    "relUrl": "/docs/Web_Backend/Web_Backend_Basics/server-01.html"
  },"113": {
    "doc": "trivias",
    "title": "trivias",
    "content": ":pencil2: 일상 기록장입니다. ",
    "url": "http://localhost:4000/docs/trivias/trivias-menu.html",
    "relUrl": "/docs/trivias/trivias-menu.html"
  },"114": {
    "doc": "공모전",
    "title": "공모전",
    "content": ":pencil2: 공모전 준비 기록장입니다 . ",
    "url": "http://localhost:4000/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/%EA%B3%B5%EB%AA%A8%EC%A0%84-menu.html",
    "relUrl": "/docs/%EA%B3%B5%EB%AA%A8%EC%A0%84/%EA%B3%B5%EB%AA%A8%EC%A0%84-menu.html"
  },"115": {
    "doc": "자료구조 기본 개념",
    "title": "자료구조란?",
    "content": "컴퓨터과학에서 자료(Data)에의 효율적인 접근과 수정을 가능하게 하는 자료의 조직, 관리, 저장을 의미한다! 자료를 구조적으로 표현하는 방식과 이를 구현하는데 필요한 알고리즘을 논하는 기초이론이다. 더 간단히 말하여, 프로그램에서 자료를 정리하여 저장하는 구조이다. ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EB%9E%80",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#자료구조란"
  },"116": {
    "doc": "자료구조 기본 개념",
    "title": "알고리즘이란?",
    "content": "문제를 해결하기 위한 절차나 방법을 의미한다. 특정한 작업을 수행하는, 명확하고 유효한 명령어들의 유한한 단계적인 절차를 의미한다. 알고리즘은 조건이 있다! . 알고리즘이기 위한 조건: . | 입력 | 출력 | 명확성 | 유한성 | 유효성 | . 알고리즘 명세 방법: . | 자연어 | 흐름도 | 유사코드(pseudocode) : 가장 많이 쓰이는 방식이다. | 프로그래밍 언어 : 가장 정확한 방법이다! | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#알고리즘이란"
  },"117": {
    "doc": "자료구조 기본 개념",
    "title": "추상데이터 타입",
    "content": "객체의 명세와 그 연산의 명세가 각각 객체의 표현과 연산의 구현으로부터 각각 분리된 자료형 을 의미한다. 딱히 구현 방법을 명시하고 있지 않다는 점에서 자료 구조와 다르다! 배열, 연결 리스트는 추상자료형이 아닌, 실제로 구현된 자료구조이다. 그렇다면 추상자료형의 예시는 무엇일까? . 추상자료형 예시 . | 복소수 | 리스트 | 스택 | 큐 | 우선순위 큐 | 트리 | 맵 | 집합 이 있다~~! | . 많이 들어보긴 했지만.. 이제 자료구조를 시작하는 입장에서 두려운 리스트이다..ㅎㅎ . 추상자료형 명시법 . 추상데이터를 정의할 때에는 ::==를 사용한다. Set Create(s) ::== 공집합기호 . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#%EC%B6%94%EC%83%81%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#추상데이터-타입"
  },"118": {
    "doc": "자료구조 기본 개념",
    "title": "저장 유형 정리",
    "content": "일반적으로 자동 저장 유형 사용을 권장한다! 변수의 값이 함수 호출이 끝난 후에도 그 값이 유지되어야 한다면, 지역 정적으로 저장한다. 만약 많은 함수에서 공유되어야한다면, 외부 참조 변수 이다. | 저장유형 | 키워드 | 정의 되는 위치 | 범위 | 생존 시간 | . | 자동 | auto | 함수 내부 | 지역 | 임시 | . | 레지스터 | register | 함수 내부 | 지역 | 임시 | . | 정적 지역 | static | 함수 내부 | 지역 | 영구 | . | 전역 | 없음 | 함수 외부 | 모든 소스 파일 | 영구 | . | 정적 전역 | static | 함수 외부 | 하나의 소스 파일 | 영구 | . | 외부 참조 | extern | 함수외부 | 모든 소스파일 | 영구 | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#%EC%A0%80%EC%9E%A5-%EC%9C%A0%ED%98%95-%EC%A0%95%EB%A6%AC",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#저장-유형-정리"
  },"119": {
    "doc": "자료구조 기본 개념",
    "title": "volatile 지정자",
    "content": "휘발성이라는 의미이다. 하드웨어가 수시로 변수의 값을 변경하는 경우에 사용됨 . volatile int io_port; //하드웨어와 연결된 변수 void wait(void){ io_port = 0; while (io_port != 255); //하드웨어가 바뀌면,io_port 값에 적용됨 } . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#volatile-%EC%A7%80%EC%A0%95%EC%9E%90",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#volatile-지정자"
  },"120": {
    "doc": "자료구조 기본 개념",
    "title": "순환(recursion)",
    "content": "자기 자신을 호출 하는 것은 순환이라고 한다. int factorial(int n) { if(n &lt;= 1) return (1); else return(n*factorial(n-1)); } . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#%EC%88%9C%ED%99%98recursion",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#순환recursion"
  },"121": {
    "doc": "자료구조 기본 개념",
    "title": "포인터",
    "content": "가장 중요하다고 강조하신 포인터! 정의: 어떤 데이터가 저장된 메모리 주소를 담고 있는 변수 . 포인터 변수를 어떤 타입(자료형)으로 선언하던지 간에!! 포인터 변수 자체의 크기는 4byte의 크기를 갖는다!! . 포인터와 관련된 연산자 . &amp; 연산자와 * 연산자 . &amp; : 주소 연산자로서, 변수의 주소를 의미한다. | : 간접참조 연산자(indirect addressing)로서, 포인터가 가르키는 주소를 의미함 따라서, *는 포인터가 가리키는 곳의 값을 나타내게 된다. | . 포인터 변수의 사용법 . | 포인터 변수의 사용 | 의미 | . | p=&amp;i | 변수 i의 주소를 포인터 변수 p에 저장 | . | printf(\"%p\", p); | 포인터 변수 p에 저장된 값(주소)를 출력 | . | printf(\"%d\", *p); | 포인터 변수 p가 가리키는 주소에 저장된 값, value를 출력 | . | *p=4; | 포인터 변수 p가 가리키는 주소에 저장된 값을 4로 대체 | . 주의사항 . | 포인터를 선언한 후에, ( *)를 사용하기 전에, 포인터는 반드시 먼저 초기화해야한다 | 포인터가 아무것도 가리키고 있지 않다면, NULL로 초기화하는게 바람직하다! int *p = NULL 이렇게 해주지 않으면, 즉, NULL 포인터를 가지고 간접 참조하면, 하드웨어로 감지할 수 있다. | . 포인터의 연산 . 포인터를 1 증가시킨다의 의미는, 포인터 타입에 해당하는 Byte 수만큼 포인터 변수 값을 증가시키는 것이다. 즉, char 타입은 바이트 수가 1이다. char *p; p++; 를 하게 되면, 포인터 p의 내용을 1만큼 증가시키게 된다. short 타입은 바이트 수가 2이다. short *p; p++; 를 하게 되면, 포인터 p의 내용을 2만큼 증가시키게 된다. 이와 똑같이, int는 4, float도 4, 그리고 double은 8이 증가하게 된다! . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#%ED%8F%AC%EC%9D%B8%ED%84%B0",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#포인터"
  },"122": {
    "doc": "자료구조 기본 개념",
    "title": "인수 전달 방법",
    "content": "call by reference, call by value 가 있다! . | call by value 인수를 함수에 전달하면, 새롭게 생성된 매개변수에 전달받은 값이 복사되어 저장된다! | . #include &lt;stdio.h&gt; void swap(int x, int y); int main (void) { int a=10, b=20; printf(\"swap 전: a= %d, b= %d\\n\",a,b); swap(a, b); printf(\"swap 후: a= %d, b= %d\\n\",a,b); return 0; } void swap(int x, int y) { int temp; temp = x; x=y; y=temp; } . 이렇게 짜게 되면, 출력은 : swap 전: a= 10, b= 20 swap 후: a= 10, b= 20 으로, 그 값이 달라지지 않는다. 그 이유는 원본데이터는 수정이 안되기 때문이다. | call by reference 인수로 전달받은 값을 복사하는 것이 아닌, 전달받은 원본 데이터에 대한 참보 변수(인수의 주소)를 매개변수에 전달/복사한다. 따라서, 그 포인터가 가르키는 그 자체가 복사되기 때문에, 함수 내부에서 값이 변경되면 함수 밖의 원본 데이터도 같이 바뀌게 된다. | . #include &lt;stdio.h&gt; void swap(int *pointer_x, int *pointer_y); int main (void) { int a=10, b=20; printf(\"swap 전: a= %d, b= %d\\n\",a,b); swap(&amp;a, &amp;b); printf(\"swap 후: a= %d, b= %d\\n\",a,b); return 0; } void swap(int *pointer_x, int *pointer_y) { int temp; temp = *pointer_x; *pointer_x = *pointer_y; *pointer_y=temp; } . 이렇게 주소값으로 접근하여 그 주소에 저장되어 있는 원본 데이터를 바꾸게 되면, swap 전: a= 10, b= 20 swap 후: a= 20, b= 10 올바르게 a와 b의 값이 바뀌어서 출력되는 것을 확인 할 수 있다. 포인터 반환할 때의 주의점 . 지역변수의 주소를 반환하면, 그 함수가 종료될 때 사라지기 때문에 오류가 발생한다!! 주소가 호출자에게 반환되고, 바로 그 포인터가 소멸하게 되면, 최종적으로 할당되지 않은 메모리(dangling pointer) 가 된다. 그리고 이러한 함수를 호출자가 사용하게 되면 문제가 발생 할 수 있다. 따라서, 반환하는 주소가 유효한 변수 가 되도록 하는 것이 중요하다!! . 해서는 안되는 예시: . int *add(int x, int y){ int result; result = x+y; return &amp;result; //이런식의 지역변수 주소 반환은 에러를 일으킬 수 있다! . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#%EC%9D%B8%EC%88%98-%EC%A0%84%EB%8B%AC-%EB%B0%A9%EB%B2%95",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html#인수-전달-방법"
  },"123": {
    "doc": "자료구조 기본 개념",
    "title": "자료구조 기본 개념",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-01.html"
  },"124": {
    "doc": "자료구조 기본 개념 (2)",
    "title": "입출력 라이브러리",
    "content": "헷갈렸던 것 하나만 적어놓도록 하겠다! . gets_s 의 사용 . 사용 형식은 다음과 같다. gets_s(입력받을 문자열 변수, 입력받을 문자열 변수의 크기); . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-02.html#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-02.html#입출력-라이브러리"
  },"125": {
    "doc": "자료구조 기본 개념 (2)",
    "title": "수행 시간 측정",
    "content": "#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; void main(void){ clock_t start, finish; double duration; start = clock(); //수행시간을 측정하고 하는 코드 //... finish = clock(); duration = (double)(finish-start)/CLOCKS_PER_SEC; printf(\"%f 초 입니다.\",duration); } . 출력: 0.000002 초 입니다. ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-02.html#%EC%88%98%ED%96%89-%EC%8B%9C%EA%B0%84-%EC%B8%A1%EC%A0%95",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-02.html#수행-시간-측정"
  },"126": {
    "doc": "자료구조 기본 개념 (2)",
    "title": "알고리즘의 성능분석 - 공간 복잡도",
    "content": "공간 복잡도: 프로그램을 수행시켜 완료하는데 필요한 공간의 양 . | 고정부분 프로그램 입출력 횟수나 크기에 관계없이 필요한 공간 보통 명령어 공간(코드 저장), 단순 변수, 구조제, 상수를 위한 공간이다. | 가변 부분 변수, 참조 변수 등이 필요로 하는 공간, 순환 호출 때는 추가로 스택 공간 인스턴스 특성에 의존적이다. 예를 들어, n개 요소를 가진 배열의 경우, n이 인스턴스 특성이 된다. 공간 복잡도 분석의 주 관심 대상이다. | . 프로그램의 공간 요구는, “ 고정부분 + 가변부분” 이다. 최선, 평균, 최악의 경우 . 최악의 경우는 가장 널리 사용된다. ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-02.html#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%84%B1%EB%8A%A5%EB%B6%84%EC%84%9D---%EA%B3%B5%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-02.html#알고리즘의-성능분석---공간-복잡도"
  },"127": {
    "doc": "자료구조 기본 개념 (2)",
    "title": "자료구조 기본 개념 (2)",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-02.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-02.html"
  },"128": {
    "doc": "빅오표기법, 순환, 배열",
    "title": "빅오",
    "content": "연산의 횟수의 대략적인 상한을 표시한다. 예. n&gt;=5 이면, 2n+1 &lt;10n 이므로 2n+1 = O(n) . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#%EB%B9%85%EC%98%A4",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#빅오"
  },"129": {
    "doc": "빅오표기법, 순환, 배열",
    "title": "빅오메가",
    "content": "그 하한을 표시한다. ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#%EB%B9%85%EC%98%A4%EB%A9%94%EA%B0%80",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#빅오메가"
  },"130": {
    "doc": "빅오표기법, 순환, 배열",
    "title": "빅세타",
    "content": "그 하한인 동시에 상한인 것을 표시한다. ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#%EB%B9%85%EC%84%B8%ED%83%80",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#빅세타"
  },"131": {
    "doc": "빅오표기법, 순환, 배열",
    "title": "알고리즘의 수행시간",
    "content": "알고리즘의 수행시간은 입력 자료 집합에 따라 다르다. 예를 들어, 순차탐색에서 찾고자 하는 숫자의 위치에 따라 그 비교횟수는 달라진다. ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%88%98%ED%96%89%EC%8B%9C%EA%B0%84",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#알고리즘의-수행시간"
  },"132": {
    "doc": "빅오표기법, 순환, 배열",
    "title": "최악의 상황",
    "content": "항상 최악의 상황을 가장 중요하게 피해야하기 때문에, 빅오를 사용한다. 순환이란? (recursion) . | 알고리즘이나 함수가 수행 도중에 자기 자신을 다시 호출하는 것 . | 피보나치 수열의 시간 복잡도 . | 순환호출 때: T(n)=T(n-1)+T(n-2)+c = … = O(2^n) | 반복으로 구현하면: T(n)=3n+c = … = O(n) | 순환호출 + “memoization” : T(n)=2n+c = O(n) | . | 하노이의 탑 . | 원판 n 개를 위쪽의 원판(n-1)개인 1뭉치와 맨 아래쪽 큰 원판 1개의 두 뭉치로 된 것을 옮긴다고 생각하며 문제 해결 | . | . 배열의 응용: 다항식 . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#%EC%B5%9C%EC%95%85%EC%9D%98-%EC%83%81%ED%99%A9",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#최악의-상황"
  },"133": {
    "doc": "빅오표기법, 순환, 배열",
    "title": "배열을 사용한 두가지 방법",
    "content": "1. 다항식의 **모든 항을 배열에 저장** 2. 다항식의 **0이 아닌 항만을** 배열에 저장 . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%91%90%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html#배열을-사용한-두가지-방법"
  },"134": {
    "doc": "빅오표기법, 순환, 배열",
    "title": "빅오표기법, 순환, 배열",
    "content": "알고리즘의 성능분석 - 빅오 표기법 . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-03.html"
  },"135": {
    "doc": "스택",
    "title": "후입선출(LIFO = Last In First Out)",
    "content": "- 입력과 역순의 출력이 필요한 경우 - 에디터에서 **되돌리기** 기능이 가능 - 함수 호출에서 **복귀 주소를 기억**한다! . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04.html#%ED%9B%84%EC%9E%85%EC%84%A0%EC%B6%9Clifo--last-in-first-out",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04.html#후입선출lifo--last-in-first-out"
  },"136": {
    "doc": "스택",
    "title": "스택 추상데이터 타입(ADT)",
    "content": "객체: 0개 이상의 원소를 가지는 유한 순서 리스트 . 연산: - create(size) ::= 공백 스택을 생성 - is_empty(s) ::= 스택이 비어있는지 검사 - is_full(s) ::= 스택이 가득 찼는가 검사 - push(s, item) ::= 스택의 맨 위에 Item 추가 - pop(s) ::= 스택의 맨 위에 있는 요소를 제거해서 return - peek(s) ::= 스택의 맨 위에 있는 요소를 제거하지 않고 return . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04.html#%EC%8A%A4%ED%83%9D-%EC%B6%94%EC%83%81%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85adt",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04.html#스택-추상데이터-타입adt"
  },"137": {
    "doc": "스택",
    "title": "스택의 구현",
    "content": "배열 –&gt; 자료구조로 바로 이해함 . 1차원 배열 stack[] 이용 . 가장 먼저 들어온 요소는 staick[0]에 저장됨 가장 최근에 들어온 요소는 stack[top]에 저장함 . 스택이 공백 상태이면 top 은 -1 . pseudo 코드로 보면 다음과 같다. is_empty(s): if top == -1{ return TRUE } else return FALSE . is_full(s): if (top &gt;= (MAX_STACK_SIZE-1)){ //스택이 5개 쌓여있으면, MAX_STACK_SIZE=5 return TRUE } else return FALSE . push 연산 . push(S, x): if is_full(s) error \"overflow\" else top &lt;- top+1 stack[top] &lt;- x . pop 연산 . pop(S): if is_empty(s) error \"underflow\" else e &lt;- stack[top] top &lt;- top-1 return e . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04.html#%EC%8A%A4%ED%83%9D%EC%9D%98-%EA%B5%AC%ED%98%84",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04.html#스택의-구현"
  },"138": {
    "doc": "스택",
    "title": "배열을 이용한 실제 스택 구현",
    "content": "#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAX_STACK_SIZE 100 typedef int element; typedef struct { element data[MAX_STACK_SIZE]; int topl } StackType; //스택 초기화 함수 void init_stack(StackType *s){ s -&gt; top = -1; } //공백 상태를 검사해주는 함수 int is_empty(StackType *s){ return(s-&gt;top == -1); } //포화 상태를 검사해주는 함수 int is_full(StackTyps *s){ return(s-&gt;top==(MAX_STACK_SIZE-1)); } //push 기능 void push(StackType *s, element item){ if(is_full(s)){ } } ## 스택의 응용 ### 괄호검사 알고리즘 - 괄호 검사 알고리즘의 개요 1. 왼쪽 괄호를 만나면 스택에 push 2. 오른쪽 괄호를 만나면 스택에서 top의 괄호를 pop하여 그 pop 한것이 그 오른쪽 괄호와 짝이 맞는지 검사하기 - 스택이 비어있다면(pop이 안되면) 왼쪽 괄호 개수/오른쪽 괄호 개수가 맞지 않는 것이거나, 같은 괄호에서 왼쪽 괄호가 먼저 안나온 경우이다. - 괄호의 짝이 맞지 않으면 쌍이 잘 맞지 않는 것이다. 3. 스택에 괄호가 남아있다면 괄호검사 false 값 return! ### 후위 표기 수식의 계산 ## 수식의 표기방법: 전위, 중위, 후위 - 중위는 거의 쓰지 않는다. - 전위 표기법: 2+3*4 - 프로그래머가 사용한다 - 괄호를 사용한다. (1+2)+7 - 후위 표기법: 2 3 4 * + - 컴퓨터가 사용한다 - 괄호를 사용하지 않는다 - 우선순위를 고려하지 않는다 - 수식을 읽으면서 바로 계산한다. -컴퓨터에서의 계산: 중위 --&gt; 후위 ## 유사코드(pseudo code) ```c cals_postfix. 스택 s를 생성하고 초기화한다. for item in 후위표기식 do if(item이 피연산자이면) push(s, item) else if(item이 연산자 op이면) second &lt;- pop(s) first &lt;- pop(s) result &lt;- first op second //op는 +-*/중의 하나 push(s,result) final_result &lt;- pop(s) . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04.html#%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%8B%A4%EC%A0%9C-%EC%8A%A4%ED%83%9D-%EA%B5%AC%ED%98%84",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04.html#배열을-이용한-실제-스택-구현"
  },"139": {
    "doc": "스택",
    "title": "스택",
    "content": "스택이란 . 스택: 쌓아놓은 더미 . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-04.html"
  },"140": {
    "doc": "큐",
    "title": "큐의 구조: 선형 큐, 원형 큐",
    "content": "front, reat . 1. front - 유효한 값 보다 하나 아래를 가리키자고 약속함 2. rear - 유효한 값 중 맨 마지막을 가리키자 ### 선형큐 배열을 선형으로 사용하여 큐를 구현한다 하지만 문제가 생겨서 잘 쓰지 않는다. (선형으로 짜면, 앞쪽이 비었어도 que full 이 되는 상황이 생긴다. 그래서 앞쪽 메모리가 비어있으면 front 를 앞으로 땡겨줘야한다! ) . 원형큐 . 말 그대로 선형이 아닌, 원 형태의 큐이다. 큐늬 front 와 rear 를 관리하기 위한 **2개의 변수**가 필요하다! front: 첫번째 요소의 하나 앞 인덱스 rear: 마지막 요소의 인덱스 . 원형큐 operation . a enqueue --&gt; front이자 rear가 됨 b enqueue --&gt; a가 front,b 가 rear 가 된다! b dequeue --&gt; b가 빠져나가고, front 가 한칸 뒤로 간다 문제: front와 rear 의 상대적인 위치로 큐가 꽉차있는지 없는지를 알아야한다. 상대적 위치만으로는 근데 알수가 없음! 이 부분에 대해서는 아래에서 다루고자 한다. 일단 단계별로 원형큐를 알아보면, 1. 초기상태 : fron = rear = 0 2. enqueue(A) : rear = (rear+1) % M ; data[rear] = item; 3. enqueue(B) : rear = (rear+1) % M; data[rear] = item; 4. dequque() : front = (front+1)%M; return data[front]; . 원형큐의 공백상태, 포화상태 . | 공백상태 : front == rear | 포화상태 : front % MAX_QUEUE_SIZE == (rear+1)%MAX_QUEUE_SIZE return ((rear+1)%M == front); (무조건 하나가 비어있어야한다! front 와 rear 사이에 한칸이 남아있는 것이 바로 포화상태!) | 오류상태 : 큐가 꽉 찼는데, front == rear 가 되면 오류이다. (모두 꽉 찼는지, 모두 비어있는지 알 수가 없게 되기 때문) | . ## 큐의 응용 : 버퍼 . | 큐는 서로 다른 속도로 실행되는 두 프로세스 간의 상호 작용을 조화시키는 버퍼 역할을 담당한다! ex. cpu와 프린터 사이의 input,output의 과정(프린팅버퍼)에서 큐가 응용된다! | 물건이 생산이 된 것을, 가운데에서 누군가가 소비자가 물건을 사는 슈퍼로 갔다놓듯이, 컴퓨터가 생산한 데이터를 QUEUE가 프린터기로 출력이 될 수 있도록 전달해주는 것이다! 이것이 바로 큐로 구성되는 버퍼이다. | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-05.html#%ED%81%90%EC%9D%98-%EA%B5%AC%EC%A1%B0-%EC%84%A0%ED%98%95-%ED%81%90-%EC%9B%90%ED%98%95-%ED%81%90",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-05.html#큐의-구조-선형-큐-원형-큐"
  },"141": {
    "doc": "큐",
    "title": "덱(deque)",
    "content": "덱은 double-ended queue의 줄임말이다. 큐의 front, rear에서 모두 삽입과 삭제가 가능한 큐를 의미한다. 쓰이는 코드: add_front, delete_front, get_front, add_rear, delete_rear, get_rear . 알아둬야하는 것 . 그냥 개인적으로 헷갈렸던 부분만 기록을 해두겠다! . | add_front(dq, e) ::= 덱의 앞에 요소를 추가한다 | delete_front(dq, e) ::= 덱의 앞에 있는 요소를 반환한 다음 삭제한다. 이것은 rear 에도 마찬가지이다. 삭제 후, 반환하는 것이 아니라 반한 한 다음 삭제한다! | get_front(dq, e) ::= peek 와 같은 기능을 한다. | . 덱의 operation . | a. 공백상태 : front == rear | b. add_front(dq, A) : data[front]=val; front =(front-1+M)%M; | c. add_rear(dq, B) : rear = (rear +1 )%M; data[rear]=item; | d. delete_rear(dq) : int prev = rear; //rear값 백업 rear = (rear-1+M)%M; return data[prev]; //삭제한 rear값의 인덱스를 prev로 넣어줌 | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-05.html#%EB%8D%B1deque",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-05.html#덱deque"
  },"142": {
    "doc": "큐",
    "title": "큐의 일상생활에서의 응용",
    "content": ". | 큐잉이론(대기이론)에 따라 시스템의 특성을 시뮬레이션하여 분석하는데 이용하기도 한다고 한다. | 뭔가 면접에서 이런 대답하면 도움이 될 것 같긴하다.. | . 큐잉이론 . 고객에 대한 서비스를 수행하는 서버, 그리고 서비스를 받는 고객들로 이루어진다! 은행에서 고객이 들어오는 것, 이 ‘큐’이고, 서비스를 받고, 다시 큐를 거쳐 나가는 것을 시뮬레이션 하는 것이다! 이를 통해 고객들이 기다리는 평균시간을 계산할 수 있기도 하다고 한다..! (정말 신기) . ### 큐잉이론 시뮬레이션 feature . | 시뮬레이션은 하나의 반복루프가 된다 | 현재시각을 나타내는 clock 변수를 사용한다. clock() 과 헷갈리면 안된다~ | [0,10) 사이의 난수를 생성 –&gt; 2보다 작으면 새로운 고객으로 판단한다!! | 고객에 대한 정보는 구조체화 한다! 고객의 아이디, 도착시간, 서비스 시간 등의 정보를 만들어 구조체에 저장한다! 이 구조제를 enqueue()를 호출하여 큐에 추가한다! | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-05.html#%ED%81%90%EC%9D%98-%EC%9D%BC%EC%83%81%EC%83%9D%ED%99%9C%EC%97%90%EC%84%9C%EC%9D%98-%EC%9D%91%EC%9A%A9",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-05.html#큐의-일상생활에서의-응용"
  },"143": {
    "doc": "큐",
    "title": "큐",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-05.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-05.html"
  },"144": {
    "doc": "다양한 리스트",
    "title": "리스트의 정의 (추상데이터 타입 )",
    "content": ". | 객체: n개의 element형으로 구성된 순서있는 모임 | 연산: . | insert(list, pos, itme) ::= pos위치에 요소를 추가한다. | insert_last(list, item) ::= 맨끝에 요소를 추가한다 | insert_first(list, item) ::= 맨 처음에 요소를 추가한다. | delete(list, pos) ::= pos 위치의 요소 삭제 | clear(list) ::= 리스트 요소 모두 삭제 | get_entry(list, pos) ::= pos 위치의 요소를 반환 | get_length(list) ::= 리스트의 길이를 구함 | is_empty(list) ::= 리스트가 비었는지 검사 | is_full(list) ::= 리스트가 꽉 찼는지 검사 | print_list(list) ::= 모든 요소 표시 | . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A0%95%EC%9D%98-%EC%B6%94%EC%83%81%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85-",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#리스트의-정의-추상데이터-타입-"
  },"145": {
    "doc": "다양한 리스트",
    "title": "리스트 구현 방법",
    "content": "리스트 구현 방법은 두가지가 있다!! . | 배열을 이용 . | 구현 간단 | 삽입, 삭제 시에 오버헤드 (요소들을 이동시킨다) | 항목의 개수가 제한되어있다 | . | 연결리스트 이용 . | 복잡하다..ㅠㅠ | 삽입, 삭제는 효율적이다!! | 크기가 제한되어있지 않다!! | . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#리스트-구현-방법"
  },"146": {
    "doc": "다양한 리스트",
    "title": "배열로 구현된 리스트",
    "content": ". | 1차원 배열에 항목들을 순서대로 저장 | 삽입연산: 삽입위치 다음의 항복들을 이동해야한다 (삽입할 위치를 만들기 위해 삽입 위치 다음의 배열들을 오른쪽으로 한칸씩 이동) | . void insert(ArrayListType *L, int pos, element item){ if(!is_full(L)&amp;&amp;(pos&gt;=0)&amp;&amp;(pos&lt;= L-&gt;size)) //리스트가 포화상태가 아니고, item 을 넣고자 하는 위치가 0이상이면서 리스트의 크기를 넘어서지 않는다면 { for (int i=(L-&gt;size-1); i&gt;=pos; i--){ //새로운 item 이 들어오는 자리pos 까지 i는 감소된다! L-&gt;array[i+1]=L-&gt;array[i]; //옆으로 옮겨진다 } L-&gt;aray[pos]=item; //item 넣기 L-&gt;size++; } } - 삭제연산: 삭제위치 다음의 항목들을 이동시켜야 한다! (삭제시키고 그 삭제된 것 기준 왼쪽 배열들을 한칸씩 왼쪽으로 이동) ## 연결 리스트 - 하나의 노드가 데이터와 링크로 구성되어있고, 링크가 노드들을 연결한다. - 다음 항목을 가리키는 주소도 같이 저장한다. - 노드: &lt;항목, 주소&gt; 쌍 - 노드는 **데이터 필드**와 **링크 필드**로 구성되어있다! - 데이터필드: 리스트의 원소, 즉 데이터 **값**을 저장 - 링크필드: 다른 노드의 **주소값**을 저장하는 장소, **포인터**의 역할을 한다. - 메모리 내에서의 노드의 물리적 순서가 리스트의 논리적 순서와 일치할 필요 없다! ### 연결리스트 장단점 장점: 삽입, 삭제가 쉬움, 연속된 메모리 공간이 필요 없음, 크기 제한이 없다!! 단점: 어렵다는 것.. ### 연결 리스트 구조 - 헤드 포인터: 리스트의 첫번째 노드를 가리키는 변수 - 노드의 생성: 필요할 때마다 동적 메모리를 생성하고 이용해서 노드를 생성한다! - 운영체제와 소통하며 리스트에서 요구를 하면, 운영체제에 갔다 온 후 동적 생성이 되는 형식.. ### 연결리스트 종류 1. 단순 연결 리스트 : 헤드포인터 --&gt; NULL - 하나의 링크 필드를 이용해 연결한다 - 마지막 노드의 링크 값은 NULL 2. 원형 연결 리스트 : 헤드포인터 --&gt; 다시 헤드포인터로 돌아온다. 3. 이중 연결 리스트 : 헤드포인터 &lt;--&gt; 다른 노드들 ## 1. 단순 연결 리스트 - 데이터 필드: 데이터 타입 정의 - 링크 필드: 포인터 사용 ```c //아래는 노드 한개의 틀이다! typedef int element; //int는 4바이트! typedef struct ListNode{ element data; //4byte struct ListNode *link; //4byte } ListNode; . | 공백 검사 어떤 리스트가 공백인지 검사하기 위해서는 –&gt; 헤드 포인터가 Null 인지 검사하면됨! ListNode *head = NULL; | head = (ListNode *)malloc(sizeof(ListNode)); sizeof(ListNode))는 총 8바이트이다! | 삽입연산 insert_first() 맨 처음에 item요소를 추가한다. head는 헤드포인터, value는 새롭게 추가되는 데이터이다! ListNode* insert_first(ListNode *head, element value); 이처럼, insert_first()는 변경된 헤더 포인터를 반환하게된다! . | 알고리즘 . | 동적 메모리 할당을 통해 새로운 노드 p를 생성 p&lt;-malloc() | p-&gt;data에 value 저장(삽입하고자 하는 item) p-&gt;data &lt;-value | p-&gt;link를 현재의 head 값으로 변경한다! p-&gt;link &lt;- head | head를 p값으로 변경한다! head &lt;-p | 변경된 헤드 포인터 반환 return head | . | 삽입연산 insert() 연결리스트 중간에 새로운 노드를 추가하는 연산이다! 삽입후에도 다른 노드들을 이동할 필요가 없다! . 30,40의 데이터를 가지고 있는 노드 사이에 35의 데이터를 가진 노드를 삽입한다는 상황에 대해 생각해보자! . | list: 연결리스트, pre: 선행노드, value: 추가할 값 이라고 지정을 하면, | pre는 20데이터를 가지고 있는 노드이고, value는 35이다. | . 수도코드: . insert(head, pre, value): p &lt;- malloc() //새로운 노드를 생성하여 변수 p로 가리킨다 p-&gt;data &lt;- value // p의 데이터 필드에 30을 저장함 p-&gt;link &lt;- pre-&gt;link //p의 링크 필드가 노드 \"40\"을 가르키도록 변경한다 pre-&gt;link &lt;-p //30의 링크필드가 35를 가리키도록 한다 return head //변경된 헤드포인터를 반환해준다 . | . 2. 원형 연결 리스트 . | 마지막 노드의 링크가 첫번째 노드를 가리키는 리스트이다! NULL 을 가리키면서 끝나는 것이 아니라, 다시 앞의 노드를 가리키는 식! | 헤드 포인터가 마지막 노드 를 가리키도록 구성하면, 리스트의 처음이나 마지막에 노드를 삽입하는 연산이 단순 연결 리스트에 비하여 용이해진다! 즉, 편의를 위해 맨 끝에 위치하는 노드를 head로 지정을 해두는 것이다. | 단순연결리스트에서처럼, 공백상태 및 초기화 상태에서 원형 연결 리스트는 헤드포인터만 필요하다! | 이중연결리스트에서는 헤드노드까지 필요하다~!~! | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#%EB%B0%B0%EC%97%B4%EB%A1%9C-%EA%B5%AC%ED%98%84%EB%90%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#배열로-구현된-리스트"
  },"147": {
    "doc": "다양한 리스트",
    "title": "원형연결리스트 : 맨앞에 삽입",
    "content": ". | head가 가르키는 것을 ‘끝’이라고 약속한다! (only for 편의) | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#%EC%9B%90%ED%98%95%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8--%EB%A7%A8%EC%95%9E%EC%97%90-%EC%82%BD%EC%9E%85",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#원형연결리스트--맨앞에-삽입"
  },"148": {
    "doc": "다양한 리스트",
    "title": "원형연결리스트 활용 : 운영체제(OS)",
    "content": ". | round robin 방식 : os의 핵심적인 부분 중 하나인 scheduling 의 대표적인 기법이다! . | 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위 로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘이다! | 여러 응용에 응답시간을 보장하는 실시간 시스템이다! | 풀어 말해서, 컴퓨터 운영을 할 때 그 컴퓨터 자원을 이용할 수 있는, 사용할 수 있는 기회를 프로그램 프로세스들에게 공정하게 부여하기 위한 방법이다! | 각 프로세스에 일정 시간을 할당하고, 그 할당된 시간이 지나면 그 프로세스는 잠시 보류를 한 후에, 다른 프로세스에 기회를 주는 식이다! 이렇게 돌아가며 기회를 부여하는 운영방식이 round robin 방식이다! | 따라서, 시간 단위(보통 100ms) 동안 수행을 다 한 프로세스는 준비큐의 끝으로 밀려나게 된다. | . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#%EC%9B%90%ED%98%95%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8-%ED%99%9C%EC%9A%A9--%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9Cos",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#원형연결리스트-활용--운영체제os"
  },"149": {
    "doc": "다양한 리스트",
    "title": "원형연결리스트 활용 : 원형큐",
    "content": ". | 원형큐는 빈공간이 있어야했고, front 와 rear 모두 관리해야했다. 이를 연결 리스트로 관리를 하게 되면 front와 rear대신 head 하나만 관리를 하면 된다는 점에서 편리하다. 또한 리스트에 있는 모든 데이터는 유효하며, 큐 포화 상태가 발생하는 일도 없다! ( 원형 연결리스트는 앞과 뒤가 연결 관리되는 형식이기 때문에) | . 2. 이중 연결 리스트 . 단순 연결 리스트도 그렇고, 이중 연결 리스트 또한 삽입, 삭제 시에 선행노드가 필요하다. 하지만 단순 연결 리스트의 경우에는 선행 노드를 찾기 어렵다는 것이 단점이다. 이러한 단순 연결리스트의 단점을 보완할 수 있는 것이 이중 연결 리스트이다. 이중 연결 리스트는, 한 노드가 그 선행 노드, 후속 노드에 대해 ‘두 개’의 링크를 모두 가지는 리스트를 의미한다. 이러한 이중연결리스트의 장점은, 링크가 양방향이므로 양방향으로 검색이 가능하다는 것이다. 방향이 한 방향만 있는 단순 연결 리스트와는 다른 점이라고 볼 수 있다. 하지만 양방향에 대한 링크 필드가 필요하다 보니 공간을 많이 차지하게 되고, 코드가 복잡해지는 단점을 가진다. 헤더노드 . 단순리스트에서는 헤더노드가 없고, 헤드의 포인터만 가진 노드가 존재했다. 하지만 리스트의 길이, 테일까지의 정보를 가지고 있는 헤더노드를 만들어 사용하면 더 편하다. typedef struct ListType{ int size; ListNode *head; ListNode *tail; } ListType; . 이러한 헤더노드는, . | 헤더노드와 헤더만 있더라도 리스트의 선언과 초기화가 가능하다. | 데이터를 가지지 않으며, 단지 ‘삽입, 삭제 코드’를 간단하게 할 목적으로 만들어지는 노드이다! | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#%EC%9B%90%ED%98%95%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8-%ED%99%9C%EC%9A%A9--%EC%9B%90%ED%98%95%ED%81%90",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#원형연결리스트-활용--원형큐"
  },"150": {
    "doc": "다양한 리스트",
    "title": "헤더노드의 활용",
    "content": ". | insert_last 에서는 헤더노드를 받아와 끝에 노드가 추가 될 때 리스트의 tail과 head의 포인터를 적절히 바꾸어주는데 쓰인다. | . 이중연결리스트에서의 노드 . | 이중연결리스트에서 임의의 노드를 가리키는 포인터를 p 라고 한다면, ` p == p-&gt;rlink-&gt;llink == p-&gt; llink-&gt; rlink` 가 성립된다. 이 부분이 잘 이핵 ㅏ안된다…ㅠㅠ | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#%ED%97%A4%EB%8D%94%EB%85%B8%EB%93%9C%EC%9D%98-%ED%99%9C%EC%9A%A9",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#헤더노드의-활용"
  },"151": {
    "doc": "다양한 리스트",
    "title": "이중연결리스트의 응용: mp3 재생프로그램!!",
    "content": "한 음악에서, 다음 음악으로 넘어갔다가 또 다시 그 전으로 넘어가는 이러한 형식은 rlink, llink 의 노드 포인터가 있는 이중연결리스트로 구현이 가능한 예시이다! . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#%EC%9D%B4%EC%A4%91%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%9D%91%EC%9A%A9-mp3-%EC%9E%AC%EC%83%9D%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html#이중연결리스트의-응용-mp3-재생프로그램"
  },"152": {
    "doc": "다양한 리스트",
    "title": "다양한 리스트",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-06.html"
  },"153": {
    "doc": "트리, 이진트리",
    "title": "트리의 용어",
    "content": "트리: 한개 이상의 노드로 이루어진 유한 집합 이다! 루트: 계층 구조에서 가장 높은 곳의 노드를 의미한다! 즉, 부모가 없는 노드이다! 서브 트리: 하나의 노드와 그 노드의 자손들로 이루어진 트리이다! (즉, 노드와 그 아래 연결된 노드들의 한 세트가 한 서브트리이다!! ) 간선 (edge) : 루트와 서브트리의 연결선을 의미한다 단말 노드(terminal node, leaf node) : 자식이 없는 노드를 의미한다! 비단말 노드(nonterminal node) : 적어도 하나의 자식을 가지는 노드이다! 부모 위치에 있는 노드들이 비단말 노드이다! 자식, 부모, 형제, 손자, 조무보, 조상, 후손 노드 : 우리가 쓰는 용어와 동일하게 트리에서도 쓰인다!! 레벨 : 트리의 각층의 번호이다! 루트가 1을 의미하고, 한층씩 내려가면서 1씩 증가한다! 높이 : 트리의 최대 레벨이다! 노드의 차수: 어떤 노드가 가지고 있는 자식 노드의 개수 트리의 차수: 트리가 가지고 있는 노드의 차수중 가장 큰 값을 의미한다! 포리스트(forest) : 트리들의 집합 . 예를 들어 아래의 그림에서, 노드 C의 차수는 3이다(C가 가지고 있는 자식의 수). 그리고 레벨은 2이다! . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%9A%A9%EC%96%B4",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#트리의-용어"
  },"154": {
    "doc": "트리, 이진트리",
    "title": "이진트리",
    "content": "일반 트리 : 노드의 차수(n)이 노드에 따라 달라진다! 이진 트리 : 모든 노드의 차수가 2 이하인 트리이다! - 모든 노드가 두개의 서브 트리를 가지고 있다! - 서브트리는 공집합일 수 있다. ( 자식이 없을 수 있다는 것.. ) - 최대 2개까지의 자식 노드가 존재한다! - 모든 노드의 차수(자식 노드의 개수)가 2 이하가 됩니다 –&gt; 이렇게 되면 구현하기가 편리하죠! - 이진트리에는 왼쪽 서브트리, 오른쪽 서브 트리를 구분합니다! 즉, 서브 트리간의 순서가 존재합니다!! 따라서, 정리하자면! . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#이진트리"
  },"155": {
    "doc": "트리, 이진트리",
    "title": "이진트리는 1. 공집합 or 루트와 왼쪽 서브트리, 오른쪽 서브트리로 구성된 노드들의 유한집합으로 정의되고! 2. 이진트리의 서브트리들은 모두 이진트리 여야 한다!",
    "content": "참고그림: 자료구조-07-02 . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EB%8A%94-1-%EA%B3%B5%EC%A7%91%ED%95%A9-or-%EB%A3%A8%ED%8A%B8%EC%99%80-%EC%99%BC%EC%AA%BD-%EC%84%9C%EB%B8%8C%ED%8A%B8%EB%A6%AC-%EC%98%A4%EB%A5%B8%EC%AA%BD-%EC%84%9C%EB%B8%8C%ED%8A%B8%EB%A6%AC%EB%A1%9C-%EA%B5%AC%EC%84%B1%EB%90%9C-%EB%85%B8%EB%93%9C%EB%93%A4%EC%9D%98-%EC%9C%A0%ED%95%9C%EC%A7%91%ED%95%A9%EC%9C%BC%EB%A1%9C-%EC%A0%95%EC%9D%98%EB%90%98%EA%B3%A0-2-%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%84%9C%EB%B8%8C%ED%8A%B8%EB%A6%AC%EB%93%A4%EC%9D%80-%EB%AA%A8%EB%91%90-%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC-%EC%97%AC%EC%95%BC-%ED%95%9C%EB%8B%A4",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#이진트리는-1-공집합-or-루트와-왼쪽-서브트리-오른쪽-서브트리로-구성된-노드들의-유한집합으로-정의되고-2-이진트리의-서브트리들은-모두-이진트리-여야-한다"
  },"156": {
    "doc": "트리, 이진트리",
    "title": "이진트리의 성질",
    "content": ". | 노드의 개수가 n개이면, 간선(edge)의 개수는 n-1개이다! 즉, 루트가 아닌 노드는 정확하게 하나의 부모를 가진다! 참고그림: 자료구조-07-03 . | 높이가 k인 이진트리가 있으면, 최소 k개의 노드를 가지고, 최대 2^k -1개의 노드를 가지게 됩니다! 노드 높이가 3이면, (2^1 -1) + (2^2 -1) + (2^3 -1) 이 총 노드의 개수이다! . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%84%B1%EC%A7%88",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#이진트리의-성질"
  },"157": {
    "doc": "트리, 이진트리",
    "title": "이진트리의 분류",
    "content": "1. 포화 이진 트리(full binary tree) : 말 그대로 노드가 최대로 채워져 있는 트리이다! 즉, 각 레벨이 꽉 차있는 트리이다! 포화 이진트리의 노드의 전체 개수는 2^k=1 로 구할 수 있다! k는 트리의 높이이다. 2. 완전 이진 트리(complete binary tree) : 높이가 k일 때, 레벨 1(루트가 있는 지점) 부터 레벨 k-1 (맨 아래에서 한칸 위) 까지는 꽉 차있고, 마지막 레벨k(가장 하단 줄)는 왼쪽부터 오른쪽으로 순서대로 노드가 채워져 있는 트리를 의미한다! . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%EB%B6%84%EB%A5%98",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#이진트리의-분류"
  },"158": {
    "doc": "트리, 이진트리",
    "title": "이진트리의 표현법!",
    "content": ". | 배열 표현법: 말그대로 배열을 이용하여 표현하는 방법이다!! | 링크 표현법: 링크(포인터)를 이용하는 방법이다! . | 리스트에서 본 링크 개념이다! 하지만 트리와 리스트는 엄청나게 다른 것임을 기억해야한다..! | . | . 01. 배열 표현법 . 일단 모든 이진트리를 포화 이진트리라고 가정한다! 즉, 모든 노드가 최대로 채워져 있다고 가정한다! 그리고 각 노드에 번호(index)를 붙여서 그 번호의 배열의 인덱스로 삼아 노드의 데이터를 배열에 저장하는 방법이다! 이렇게 표현을 하게되면, 트리를 계산하기에 굉장히 편해진다! 그리고 인덱스0 또한 계산의 편의를 위해 사용하지 않는다. 하지만, 가정 자체가 모두 “꽉 꽉 채워져 있다”라는 것이었기 때문에, 이진트리가 조금 비어있게 되면 배열에서 빈 칸이 많이 생겨서 기억 공간이 낭비될 수도 있다는 단점이 있다! . - 배열 표현법에서의 부모와 자식 인덱스 관계 노드 i의 부모 노드 인덱스는 = i/2 이다! (정수 부분만) 노드 i의 왼쪽 자식 노드 인덱스는 = 2i 이다! 노드 i의 오른쪽 자식 노드 인덱스는 = 2i+! 이다! . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#%EC%9D%B4%EC%A7%84%ED%8A%B8%EB%A6%AC%EC%9D%98-%ED%91%9C%ED%98%84%EB%B2%95",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html#이진트리의-표현법"
  },"159": {
    "doc": "트리, 이진트리",
    "title": "트리, 이진트리",
    "content": "tree . 트리: 계층적인 구조를 나타내는 자료구조이다! - 트리의 계층적인 구조와 다르게, 리스트, 스택, 큐 등은 선형으로 나열되어있다. 이러한 것들은 선형 구조이다! . | 트리는 부모-자식 관계의 노드들로 구성된다! | 회사 조직과 같은 계층적인 조직 표현, 컴퓨터 디스크의 디렉토리 구조, 또는 인공지능에서의 결정트리(decision tree)에서 쓰일 수 있는 아주 중요한 자료구조 개념이당ㄷ~~~ | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-07.html"
  },"160": {
    "doc": "이진트리의 순회",
    "title": "이진 트리의 순회 &amp; 순회방법",
    "content": "순회(traversal): 이진 트리에 속하는 모든 노드를 한 번씩 방문하여 노드가 가진 데이터를 목적에 맞게 처리하는 것을 의미한다! . 부모노드는 자식노드를 아는데, 자식노드는 부모노드를 찾아갈 수 없다. 순회방법 . **의미: V-루트 노드 방문 L-왼쪽 서브 트리를 방문 R-오른쪽 서브 트리를 방문 . | 전위 순회(preorder traversal) : V-L-R . | 자손 노드보다 루트 노드를 먼저 방문한다! | 이진트리에 대해서는, 왼쪽 노드를 먼저 방문하는 깊이우선탐색(DFS)순서는 전위 순회 순서와 같다 | . | 중위 순회(inorder traversal): L-V-R -왼쪽 자손, 루트, 오른쪽 자손 순으로 방문하는 방식이다! | 후위 순회(postorder traversal): L-R-V . | 루트 노드보다 자손을 먼저 방문한다! | . | . 이 세가지는, 이진트리로 많이 구현된다. (그 이유는..) **이진트리 자체도 순환 방식으로 정의되어있다! (이진트리: 왼쪽 서브트리와 오른쪽 서브트리로 구성된 노드들의 유한 집합) . 순회방법 01. 전위순회(V-L-R)알고리즘 . | 트리 전위 순회 알고리즘 ```c //유사코드 | . preorder(x): . | if x!=NULL | then print DATA(x); | preorder(LEFT(x)); | preorder(RIGHT(x)); | . 설명: 1. 노드 x가 NULL이면 더 이상 순환호출을 하지 않는다. 2. x의 데이터를 출력한다.(x는 루트노드) 3. x의 왼쪽 서브트리를 순환호출하여 방문한다. 4. x의 오른쪽 서브트리를 순환호출하여 방문한다. ### 순회방법 02. 중위순회(L-V-R)알고리즘 - 트리 중위 순회 알고리즘 ```c //유사코드 inorder(x): 1. if x!=NULL 2. then inorder(LEFT(x)); 3. print DATA(x); 4. inorder(RIGHT(x)); . 순회방법 03. 후위순회(L-R-V)알고리즘 . | 트리 후위 순회 알고리즘 ```c //유사코드 | . postorder(x): . | if x!=NULL | then postorder(LEFT(x)); | postorder(RIGHT(x)); | print DATA(x); | . ``` . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%88%9C%ED%9A%8C--%EC%88%9C%ED%9A%8C%EB%B0%A9%EB%B2%95",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#이진-트리의-순회--순회방법"
  },"161": {
    "doc": "이진트리의 순회",
    "title": "이러한 순환 호출은",
    "content": "많이 사용하고 있고, 이해하기도 쉽다! . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#%EC%9D%B4%EB%9F%AC%ED%95%9C-%EC%88%9C%ED%99%98-%ED%98%B8%EC%B6%9C%EC%9D%80",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#이러한-순환-호출은"
  },"162": {
    "doc": "이진트리의 순회",
    "title": "이진 트리의 순회 : 구현방법 ( 반복 이용 )",
    "content": "스택이 필요하다!! 스택에 자식 노드를 저장한다, 그리고 그 자식 노드 스택을 꺼내면서 순회하도록 구현한다. ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%88%9C%ED%9A%8C--%EA%B5%AC%ED%98%84%EB%B0%A9%EB%B2%95--%EB%B0%98%EB%B3%B5-%EC%9D%B4%EC%9A%A9-",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#이진-트리의-순회--구현방법--반복-이용-"
  },"163": {
    "doc": "이진트리의 순회",
    "title": "이진 트리의 순회: 레벨 순회",
    "content": "레벨 순회(level order)는 각 노드를 레벨순으로 방문하는 순회방법이다! 레벨 순회는 큐를 이용하는 순회방법이다! 이진 트리에 대해서는, (왼쪽 노드를 먼저 방문하는) 너비우선탐색(BFS)순서는 레벨 순회 순서와 같다! . 레벨 순회의 알고리즘 . | 루트 노드를 큐에 삽입한다. | 큐에 있는 노드를 꺼내어 방문 한다음, 그 방문한 노드의 자식 노드들을 큐에 삽입한다! | 이 동작을 큐가 빌 때까지 계속한다. | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%88%9C%ED%9A%8C-%EB%A0%88%EB%B2%A8-%EC%88%9C%ED%9A%8C",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#이진-트리의-순회-레벨-순회"
  },"164": {
    "doc": "이진트리의 순회",
    "title": "트리의 응용: 수식 트리 처리",
    "content": "수식트리: 산술식을 트리형태로 표현한 것이다! . | 비단말노드: 연산자 | 단말노드: 피연산자 | . 이런 수식 트리를, 전/중/후위 순회로 읽게되면! 각각 전/중/후위 표기 수식이 되어서 출력된다! . 그림을 통해 이해해보자: 자료구조-08-01.png . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%9D%91%EC%9A%A9-%EC%88%98%EC%8B%9D-%ED%8A%B8%EB%A6%AC-%EC%B2%98%EB%A6%AC",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#트리의-응용-수식-트리-처리"
  },"165": {
    "doc": "이진트리의 순회",
    "title": "트리의 응용: 트리 속의 구성요소들의 개수 구하기",
    "content": ". | 트리내의 노드 개수 . | 각각의 서브트리에 대해 순환 호출 | 반환되는 값에 1(자기자신)을 더하여 반환한다!! ```c int get_node_count(TreeNode *node) { int count =0; . if(node != NULL) count = 1+ get_node_count(node-&gt;left) + get_node_count(node-&gt;right); . return count; } . | . ``` . | 단말 노드의 개수 . | 순회 하면서, 왼쪽 자식과 오른쪽 자식이 동시에 0이 되게 되면, 단말 노드라고 판단한다! | 단말 노드일 때에는 1 를 반환 | . int get_leaf_count(TreeNode *node) { int count = 0; if( node != NULL){ if (node-&gt;left == NULL &amp;&amp; node-&gt; right == NULL){ return 1; } else{ count = get_leaf_count(node-&gt;left) + get_leaf_count(node-&gt;right); } } return count; } . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%9D%91%EC%9A%A9-%ED%8A%B8%EB%A6%AC-%EC%86%8D%EC%9D%98-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C%EB%93%A4%EC%9D%98-%EA%B0%9C%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#트리의-응용-트리-속의-구성요소들의-개수-구하기"
  },"166": {
    "doc": "이진트리의 순회",
    "title": "수식 트리 - 기출문제1",
    "content": ". | 후위 표기식을 전위 표기식으로 바꾸기! 제시된 식: A B C * D / + E - | . 풀이: . | 중위 표기식을 구한다. (((B*C)/D)+A)-E . | 수식트리를 그린다. - / \\ . | E / \\ A / / \\ * D / \\ B C | . | 전위 순회 (V-L-R) . | . | A / * B C D E | . | . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#%EC%88%98%EC%8B%9D-%ED%8A%B8%EB%A6%AC---%EA%B8%B0%EC%B6%9C%EB%AC%B8%EC%A0%9C1",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html#수식-트리---기출문제1"
  },"167": {
    "doc": "이진트리의 순회",
    "title": "이진트리의 순회",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-08.html"
  },"168": {
    "doc": "이진탐색트리",
    "title": "스레드 이진 트리",
    "content": ". | 이진트리에 있는 NULL 링크를 이용해, 순환 호출 없이도 트리의 노드들을 순회할 수 있는 트리이다! | 정의 : NULL 링크에, 중위 순회때의 후속 노드인 중위 후속자를 저장시켜놓은 트리 | . 스레드 이진 트리의 구현 (single threaded) . | 단말노드와 비단말노드의 구별을 위해 is_thread 필드가 필요하다! | is_thread 가 TRUE 이면, right 은 중위후속자, 즉 노드의 오른쪽 위의 노드를 가르킨다. | is_thread 가 FALSE 이면, right 은 오른쪽 자식을 가리키는 링크가 된다. | . 이 스레드 이진트리의 자료구조는 다음과 같다. typedef struct TreeNode { int data; struct TreeNode *left, *right; int is_thread; //만약 오른쪽 링크가 스레드이면 TRUE } TreeNode; . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#스레드-이진-트리"
  },"169": {
    "doc": "이진탐색트리",
    "title": "이진탐색트리: 용어",
    "content": "탐색이란: 레코드의 집합에서 특정한 레코드를 찾아내는 작업 . | 레코드 : 필드들의 집합, 구조체를 의미한다! | . 레코드 관련 용어 . 이 부분은 웹 개발에서도 많이 활용되기 때문에 필수적인 개념이라고 생각한다! - 레코드는 보통 key라고 불리는 필드에 의해 식별된다. - 고유(unique)한 값의 Key를 primary key라고 부른다. 예. 구조체의 학번, 주민등록번호 등 - 탐색 작업 : 이러한 Key가 입력되어 특정한 값을 가진 레코드를 찾게 된다! –&gt; 이진 탐색 트리는 탐색 작업에 효율적인 자료구조를 제공한다!! - 필드(field): 멤버(member )또는 원소(element) –&gt; 필드 1: 학번, 필드 2: 이름, 필드 3: 주소 와 같은 개념이다. - 테이블 : 레코드의 집합을 의미 . 구조 사진: 자료구조-09-01.png . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC-%EC%9A%A9%EC%96%B4",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#이진탐색트리-용어"
  },"170": {
    "doc": "이진탐색트리",
    "title": "이진탐색트리: 정의",
    "content": ". | 이진탐색트리에서, 모든 원소의 키(key)는 유일하고, 고유한 값이다. | 항상 key(왼쪽 서브 트리)의 값 &lt; key(루트노드) &lt; key(오른쪽 서브 트리)의 값 의 룰이 적용되며, 잊지 말아야 할 점은 왼쪽과 오른쪽 서브 트리도! 그 자체만으로 이진 탐색 트리이다! | 이러한 룰로 이진탐색트리가 구성되기 때문에, 중위순회를 하게 되면 자동적으로 오름차순으로 그 노드의 값들이 정렬되게 된다..!! | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC-%EC%A0%95%EC%9D%98",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#이진탐색트리-정의"
  },"171": {
    "doc": "이진탐색트리",
    "title": "이진탐색트리: 탐색연산",
    "content": ". | 주어진 탐색키 값과 루트 노드의 키 값을 비교함 . | 맨 위에 18이 루트이고, 12를 찾으려고 하는 거라면 왼쪽 자식부터 탐색한다. | 그 아래 자식은 7이다. 그렇다면 탐색하고자 하는 12는 7보다 크기 때문에 오른쪽 자식부터 탐색을 다시 한다. | 비교한 결과가 같으면 탐색 성공, 끝난다! | . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC-%ED%83%90%EC%83%89%EC%97%B0%EC%82%B0",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#이진탐색트리-탐색연산"
  },"172": {
    "doc": "이진탐색트리",
    "title": "이진탐색트리: 삽입연산",
    "content": ". | 좋은 삽입 연산 알고리즘의 기준은, 구조 변경이 최소화되는 트리이다! | 삽입을 하기 위해서는!! 무조건 먼저 탐색을 하는 것이 기본이다! | 탐색에 실패한 위치, 즉 NULL 값이 return 되는 지점이 새로운 노드를 삽입하는 위치이다! | 삽입은 없는 것을 만들어내는 것, 수정이 아니다! | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC-%EC%82%BD%EC%9E%85%EC%97%B0%EC%82%B0",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#이진탐색트리-삽입연산"
  },"173": {
    "doc": "이진탐색트리",
    "title": "이진탐색트리의 성능분석",
    "content": ". | 최선 : 이진 트리가 균형적으로 생성되어 있는 경우 | 최악 : 한쪽으로 치우친 경사이진트리의 경우 | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%84%B1%EB%8A%A5%EB%B6%84%EC%84%9D",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html#이진탐색트리의-성능분석"
  },"174": {
    "doc": "이진탐색트리",
    "title": "이진탐색트리",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-09.html"
  },"175": {
    "doc": "그래프, DFS",
    "title": "그래프",
    "content": ". | 연결되어 있는 객체 간의 관계를 표현하는 자료구조 | 가장 일반적인 자료구조형태 이다! . | tree 도 그래프의 특수한 경우이다!! | . | . 그래프로 표현하는 것들 . | 도로망 ( 일반통행, 사거리 등 ) | 선수과목 관계 | 미로 ( 현재의 위치에서 가능한 방향 을 스택에 저장, 막다른 길을 만나면 스택에서 다음 탐색 위치를 꺼낸다! ) | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#%EA%B7%B8%EB%9E%98%ED%94%84",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#그래프"
  },"176": {
    "doc": "그래프, DFS",
    "title": "그래프의 정의",
    "content": ". | 정점(vertex)와 간선(edge)의 유한집합이다!! | 수학적: G=(V,E) . | 정점 | . | 여러 가지 특성을 가질 수 있는 객체를 의미한다! | V(G): 그래프 G의 정점들의 집합 | 예: V(G1) = {0,1,2,3} | 노드라고 불린다! . | 간선 | . | 정점들 간의 관계! | E(G): 그래프 G의 간선들의 집합 | E(G1)={(0,1),(0,2),(0,3),(1,2)} 로 표현한다! | link 라고도 불린다. | . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EC%A0%95%EC%9D%98",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#그래프의-정의"
  },"177": {
    "doc": "그래프, DFS",
    "title": "그래프 표현 방법",
    "content": ". | 인접 행렬 . | 정점 수가 n이라면, nxn의 2차원 배열 | 무방향 그래프의 인접 행렬은 대칭을 이루게 됨 | 방향 그래프는 대칭이 아니다. | 인접 행렬의 대각선 성분은 모두 0 이다. | 필요 공간: n^2 비트 | . | 인접 리스트 . | 각 정점(노드)에 인접한 정점들을 연결리스트로 표현한다! | 각 연결리스트의 노드들: 인접 정점을 저장한다! | 헤드 노드들은 1차원 배열이다! 정점 i는 인덱스 i로 접근한다. | . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#%EA%B7%B8%EB%9E%98%ED%94%84-%ED%91%9C%ED%98%84-%EB%B0%A9%EB%B2%95",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#그래프-표현-방법"
  },"178": {
    "doc": "그래프, DFS",
    "title": "그래프의 탐색",
    "content": "- 그래프의 가장 기본적인 연산이다! - 순회를 의미한다! --&gt; 하나의 정점으로부터 시작하여 **차례대로 모든 정점들을 한번씩 방문** 하는! 탐색은 곧 순회를 의미한다! 1. 깊이 우선 탐색 - 전위, 스택 이용 2. 너비 우선 탐색 - 레벨, 큐 이용 . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%ED%83%90%EC%83%89",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#그래프의-탐색"
  },"179": {
    "doc": "그래프, DFS",
    "title": "1. 깊이 우선 탐색 (DFS)",
    "content": ". | 한 방향으로 내려갈 수 있을 때까지 내려가보자! | 내려가다가 더이상 못 내려가면 갈림길로 돌아온다! 돌아오고, 돌아온 갈림길 부터 다른 방향으로 다시 탐색을 진행한다! 이렇게 되돌아가기 위해서는 스택이 필요하다!! | 활용 예: 미로찾기, 트리의 전위 순회 | . pseudo code: . depth_first_search(v): v를 방문되었다고 표시 for all u 속한다 (v에 인접한 정점) do if (u가 아직 방문되지 않았으면) then depth_first_search(u) . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#1-%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89-dfs",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#1-깊이-우선-탐색-dfs"
  },"180": {
    "doc": "그래프, DFS",
    "title": "2. 너비 우선 탐색 (BFS)",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#2-%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89-bfs",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html#2-너비-우선-탐색-bfs"
  },"181": {
    "doc": "그래프, DFS",
    "title": "그래프, DFS",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-10.html"
  },"182": {
    "doc": "신장트리, Kruskal, Prim",
    "title": "신장트리(spanning tree)",
    "content": ". | 그래프의 간선들로만 구성됨 | 모드 정점 포함! | 부분 그래프 중에서 모든 정점을 포함하는 트리를 의미한다! | n개의 정점을 가지는 그래프의 신장트리는 n-1개의 간선을 가진다! | 최소의 링크를 사용하는 네트워크 구축시에 사용된다. ex. 통신망, 도로망, 유통망 | DFS 또는 BFS 도중에 사용된 간선만 모으게 되면, 신장트리가 된다! | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-11.html#%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%ACspanning-tree",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-11.html#신장트리spanning-tree"
  },"183": {
    "doc": "신장트리, Kruskal, Prim",
    "title": "최소비용 신장트리",
    "content": ". | MST : minimum spanning tree | 최저의 비용을 갖는 신장트리이다. | 신장트리중에서 사용된 간선들의 가중치 함이 최소인 신장트리이다! | 즉, 네트워크 내 모든 정점들을 가장 적은 수의 간선과 비용으로 연결해주는 트리이다. | 도시들을 모두 연결하면서 도로의 길이를 최소로하는 문제가 있을 수 있는 도로 건설 분야에서도 응용 될 수 있고, 단자들을 모두 연결하고 그 전선의 길이를 가장 최소로 하는 문제가 있을 수 있는 전기 회로분야에서도 활용가능하다. 이 외에도 통신분야의 전화선 길이(전화 케이블 망 구성), 배관(파이프를 모두 연결할 때의 파이프의 총 길이를 최소화 하는 문제) 에 활용 될 수 있다. | . 신장트리의 제한 조건 . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-11.html#%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9-%EC%8B%A0%EC%9E%A5%ED%8A%B8%EB%A6%AC",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-11.html#최소비용-신장트리"
  },"184": {
    "doc": "신장트리, Kruskal, Prim",
    "title": "Kruskal 의 MST 알고리즘, Greedy Method",
    "content": ". | 간단하게 말해서, 최소비용 스패닝트리를 구하는 Kruskal의 알고리즘이다. | Kruskal 외에도 Prim 알고리즘도 있다. | 주요 알고리즘 설계 기법으로서, 각 단계에서 최선의 답은 선택하는 과정을 반속하여 최종적인 해답에 도달하는 알고리즘이다. 이 때 이러한 greedy method 가 항상 최적의 해답을 준다는 것은 보장이 안된 부분이기 때문에, 이 부분에 대해서는 검증이 필요하다. 또한 한번 내려진 결정에 대해서는 번복이 불가하기 때문에 각각의 결정이 가능한 해를 도출해낼 수 있는지 확인해야한다. | Kruskal이 20분만에 발견한 알고리즘이어서, 굉장히 직관적인 알고리즘이다! . | spanning tree(간선트리)이기 때문에 사이클을 포함하지 않고, 최소 비용의 간선으로 구성되어있다. | 이 알고리즘에서는 각 단계에서 사이클을 이루지 않는 최소 비용 간선을 선택하는데, 이 때 그래프의 간선들을 가중치의 오름차순으로 정렬하게 된다. 그리고 그렇게 정렬된 간성 중에서 사이클을 형성하지 않는 간선을 현재의 MST집합에 추가한다. | pesudo code : ```c //가중치 그래프 G=(V,E) //n은 노드의 개수이다 //출력되는 것은, 최소비용 신장 트리를 이루는 간선들의 집합인 Et Kruskal(G) E를 w(e1)&lt;= … &lt;=w(e) 가 되도록 정렬함 //가중치의 오름차순으로 정렬한다 Et &lt;-공집합 값; encount &lt;-0 . while encounter&lt;(n-1) do k &lt;- k+1 if Et &lt;-Et 합집합 {ek}가 사이클을 포함하지 않는다면 then Et &lt;-Et 합집합 {ek}; encounter &lt;- encounter+1 . return . | . ## Kruskal MST - union-find 알고리즘 - 두 집합들의 **합집합**을 만드는 알고리즘이다. - 원소가 어떤 집합에 속하는지 알아낸다 - 어떤 집합에 속하는지를 알아내어, 같은 집합의 원소끼리는 사이클이 형성되고, 다른 집합에 속하면 사이클이 형성되지 않음으로서 Kruskal의 MST 알고리즘에서 **사이클 검사**에 사용이 될 수 있다! ## Kruskal MST 알고리즘 복잡도 - Kruskal 알고리즘의 복잡도를 결정하는 가장 중요한 요소는 '간선 정렬 시간'이다. - 오히려 사이클 테스트 등의 작업은 정렬에 비해 신속하게 수행되는편이다! ## Prim의 MST 알고리즘(자연어) - 시작 정점에서부터 출발하여 신장 트리 집합을 **단계적으로 확장해나간다** - 시작 단계에서는 **시작 정점만이** 신장 트리 집합에 포함된다! - 앞 단계의 신장 트리 집합에, **인접한 정점** 중에서 최소 비용 간성으로 연결된 정점을 선택해서 신장 트리 집합에 추가하게 된다. - 이 과정은 신장 트리 집합이 n-1개의 간선을 가질 때 까지 반복한다! pseudo code: ```c Prim(G, s): Vt-{s}; vcounter &lt;-1 while vcounter &lt; n do (u,v)는 u는 Vt의 원소이고 and v는 Vt의 원소가 아닌 최저 비용 간선; if (그러한 (u,v)가 존재하면) //예외처리 then Vt &lt;-Vt합집합v; vcounter &lt;- vcounter+1 else 실패(신장트리 없음) //예외처리 return Vt . 조금더 구체적인 psuedo code: . Prim(G,s) for each (V의 원소인 u) do dist[u] &lt;- 무한대 dist[s] &lt;-0 우선 순위로 Q에 모든 정점을 삽입한다(우선순위는 dist[]) // dis[]는 현재까지 알려진 신장트리 정점 집합에서 각 정점까지의 거리(distance)를 의미한다. for i&lt;-0 to n-1 do u &lt;- delete_min(Q) 화면에 u를 출력한다 for each (u의 인접 정점의 원소인 v) if(Q의 원소가 v라면, 그리고(and) weight[u][v] &lt; dis[v]라면,) then dist[v] &lt;- weight[u][v] . | 주 반복문이 정점의 수 n만큼 반복하고, 내부 반복문이 n번 반복한다! –&gt; O(n^n)의 복잡도를 가지게 된다! | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-11.html#kruskal-%EC%9D%98-mst-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-greedy-method",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-11.html#kruskal-의-mst-알고리즘-greedy-method"
  },"185": {
    "doc": "신장트리, Kruskal, Prim",
    "title": "신장트리, Kruskal, Prim",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-11.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-11.html"
  },"186": {
    "doc": "최단경로, Dijkstra",
    "title": "최단 경로(shortest path)",
    "content": ". | 네트워크에서 정점 u와 정점 v를 연결하는 경로 중에서 간선들의 가중치 합이 최소가 되는 경로 | 간선의 가중치로는, 비용, 거리, 시간 등이 있을 수 있다. | 예를 들어, 정점 0 에서 정점 3으로 가는 최단경로문제에서, 0,4,1,2,3이 최단경로이면, 이 때 인접행렬에서 간선이 없는 노드쌍의 가중치는 무한대 값을 가진다. | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-12.html#%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9Cshortest-path",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-12.html#최단-경로shortest-path"
  },"187": {
    "doc": "최단경로, Dijkstra",
    "title": "Dijkstra의 최단경로 알고리즘",
    "content": ". | 하나의 시작정점으로부터 모든 다른 정점 까지의 최단경로(길이만!) 을 찾는다. single source multiple destination path라고 불린다고 한다. | 전제조건: 모든 간선의 가중치는 0또는 양수이다! 음이 되면 Dijkstra 알고리즘은 돌아가지 않는다고한다 | 집합 S : 시작 정점 v로부터의 최단경로가 이미 발견된 정점들의 집합을 의미한다, 이 집합 S의 초기치는 {V}이다. | 가중치 인접 행렬의 weight는, 직접 연결된 간선이 있으면, weight[v][w]=간선v-&gt;w의 가중치, 없으면, weight[v][w]=무한대값 으로 정의한다. | distance 배열 . | 최단경로가 알려진 정점들(즉, 집합 S의 원소들)만을 이용한 다른 정점들까지의 최단경로 길이(가중치의 합!) | . | distance 배열의 초기값 : 시작 정점 v로 부터, . | 자기 자신 정점 v까지의 길이는 distance[v]=0 이다. | 다른 정점 w까지의 길이는 distance[w]=weight[v][w] 이다! | . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-12.html#dijkstra%EC%9D%98-%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-12.html#dijkstra의-최단경로-알고리즘"
  },"188": {
    "doc": "최단경로, Dijkstra",
    "title": "Dijkstra의 최단경로 알고리즘 설명",
    "content": ". | 매 단계에서, S안에 있지 않은 정점중에서, 즉 시작 정점 v로부터 최단경로가 이미 발견되지 않은 정점들 중에서 가장 distance 값이 작은 정점을 s에 추가한다! | 이렇게 되면, 최종적으로 distance[]는 시작정점에서 모든 정점까지의 최단거리가 된다! | psuedo code: ```c shortest_path(G,v): //Dijkstra의 최단경로 알고리즘 | . S &lt;-{V} for (G에 속해있는 각 정점 w) do distance[w] &lt;-weight[v][w]; while 모든 정점이 S에 포함되지 않으면 do u &lt;- 집합 S에 속하지 않는 정점 중에서 최소 distance 정점; S &lt;- S 합집합 {u} for (u에 인접하고 S에 있는 각 정점 z) do if distance[u]+weight[u][z] &lt; distance[z] then distance[z] &lt;-distance[u]+weight[u][z]; ``` . 이 때 for문이 두개 중첨되어 있기 때문에, O(n^2)의 복잡도를 가지게 된다. ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-12.html#dijkstra%EC%9D%98-%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%84%A4%EB%AA%85",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-12.html#dijkstra의-최단경로-알고리즘-설명"
  },"189": {
    "doc": "최단경로, Dijkstra",
    "title": "최단경로, Dijkstra",
    "content": " ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-12.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-12.html"
  },"190": {
    "doc": "정렬",
    "title": "정렬",
    "content": ". | 물건을 크기 순으로 오름차순이나 내림차순으로 나열하는 것 | 컴퓨터 공학을 포함한 모든 과학 기술 분야에서 가장 기본적이고 중요한 알고리즘 중 하나이다! | 특히 자료 탐색에 필수적이다! . | 정렬의 대상: 레코드라고 부른다! 레코드 속에서 많은 필드가 있을 수 있다. 예를 들어 학생들의 레코드라면, 학번/이름/주소 등의 필드가 존재한다. 그리고 정렬의 기준이 되는 것은 키(key)라고 부르며, 한 필드는 Key가 되어 정렬이 된다. | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html"
  },"191": {
    "doc": "정렬",
    "title": "정렬 알고리즘 한눈에 보기!!",
    "content": ". | 단순하지만 비효율적인 방법 . | 선택정렬, 삽입정렬, 버블정렬 | . | 복잡하지만 효율적인 방법 . | 합병정렬, 퀵정렬, 기수정렬, 히프정렬 등 | . | 내부 정렬 . | 모든 데이터가 주기억장치에 저장되어진 상태에서 정렬 | . | 외부 정렬 . | 외부기억장치에 대부분의 데이터가 있고 일부만 주 기억장치에 저장된 상태에서 정렬 | . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%95%9C%EB%88%88%EC%97%90-%EB%B3%B4%EA%B8%B0",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#정렬-알고리즘-한눈에-보기"
  },"192": {
    "doc": "정렬",
    "title": "안정적인 정렬 알고리즘은?",
    "content": ". | 동일한 키 값을 갖는 레코드들의 상대적인 위치가 정렬 후에도 바뀌지 않는 것이 중요하다! | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%80",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#안정적인-정렬-알고리즘은"
  },"193": {
    "doc": "정렬",
    "title": "01. 합병정렬",
    "content": "입력파일: 27,10,12,20,15,35,33,44 이 있으면, 좌 우 4개씩 분할하고, 그 분할 된 것을 2개씩으로 분할하고 하나씩으로 분할하여 다 분할이 되고 나서는, 합병을 하면서 정렬을 하는 것이다. | 재귀호출이 사용된다! | pseudo code if left&lt;right mid = (left+right)/2; merge_sort(list,left,mid); merge_sort(list,mid+1,right); merge(list,left,mid,right); . | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#01-%ED%95%A9%EB%B3%91%EC%A0%95%EB%A0%AC",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#01-합병정렬"
  },"194": {
    "doc": "정렬",
    "title": "합병정렬 복잡도 분석",
    "content": ". | 레코드의 크기가 큰 경우에는 시간낭비가 될 수 있다..! 레코드를 연결리스트로 구성하여 합병정렬하게되면, 링크 인덱스만 변경되어서 데이터의 이동은 무시할 수 있을 정도로 작아진다! –&gt; 이렇게 하면 크기가 큰 레코드를 정렬하더라도 다른 정렬방법보다 효율적이다! | 최적, 평균, 최악의 경우 큰 차이없이 O(nlog(n))의 복잡도를 가진다! (크기 n인 리스트를 정확히 균등 분배하기 때문에 log(n)개 패스하고, 각 패스에서 리스트의 모든 레코드n개를 비교하므로 n번의 비교연산이 돌아가서 nlog(n)이 된다! ) | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#%ED%95%A9%EB%B3%91%EC%A0%95%EB%A0%AC-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B6%84%EC%84%9D",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#합병정렬-복잡도-분석"
  },"195": {
    "doc": "정렬",
    "title": "퀵정렬 (quick sort)",
    "content": ". | 평균적으로 가장 빠른 정렬방법 이다! | 분할정복법을 사용한다 | 리스트 2개의 부분 리스트로 비균등 분할을 하고, 그리고 재귀호출을 이용해 각각의 부분 리스트를 다시 퀵정렬을 한다. | 입력된 리스트의 제일 왼쪽은 피벗이라고 한다. 그리고 그 리스트를 피벗보다 작은 값과 큰값으로 나누어 그 가운데에 피벗이 삽입된다. | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#%ED%80%B5%EC%A0%95%EB%A0%AC-quick-sort",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#퀵정렬-quick-sort"
  },"196": {
    "doc": "정렬",
    "title": "큌정렬 알고리즘(자연어로)",
    "content": "정렬할 레코드 개수가 2개 이상이면(if left&lt; right ), 그 정렬할 레코드중 피벗(pivot)레코드를 선택한다. 정렬할 레콛 개수가 2개 이상이 아니라면, 즉 한개라면 정렬이 완료되었다고 리턴한다. 정렬할 레코드들은 피벗의 왼쪽에는 피벗의 키보다 작거나 같은 레코드들을 위치시키고, 오른쪽에는 피벗의 키보다 크거나 같은 레코드들을 위치시키며 정돈한다. 퀵 정렬을 순환적으로 사용하여서 피벗의 왼쪽과 오른쪽의 레코드들을 서로 독립적으로 정렬시키도록 한다. 정렬할 key들의 부분 리스트를 list[] 라고 하고, left는 list[]의 제일 왼쪽 레코드의 인덱스, right은 list[]의 제일 오른쪽 레코드의 인덱스라고 했을 때 큌정렬은 다음과 같이 만들어진다. quick_sort(list[],left,right): 정렬할 범위가 2개 이상의 데이터이면, partition 함수를 호출하여 피벗을 기준으로 2개의 리스트로 분할한다. partition 함수의 반환값이 피벗의 위치이다. (피벗위치에 대해) 피벗보다 큰 것들은 오른쪽으로, 작은 것 들은 왼쪽으로 맞교환하여 배치하게 되고, 피벗을 크기에 맞게 그 사이로 이동한 다음 그 피벗 위치를 반환한다. left 에서 피벗 바로 앞 까지를 대상으로 순환호출하게 된다. 이 때 피벗은 제외된다! 피벗 바로 다음부터 right 까지를 대상으로 순환호출한다, 이 때도 피벗은 제외된다. partition(list[],left,right): . low &lt;-left+1 //제일 왼쪽 값 left 다음 값을(+1) low 라고 한다. high &lt;- right //제일 오른쪽 값은 high라고 한다. list[제일 왼쪽]을 pivot 으로 선택한다 list[low] &gt;=pivot이 아니면, low를 증가시킨다. list[high] &lt;= pivot이 아니면, hight를 감소시킨다. low &lt; high 이면 list[low]와 list[high]를 교환한다 low &lt; high 이면 위의 3개 단계를 반복한다 pivot과 list[high]를 교환한다 피벗의 위치로 high를 반환한다 . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#%ED%81%8C%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9E%90%EC%97%B0%EC%96%B4%EB%A1%9C",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#큌정렬-알고리즘자연어로"
  },"197": {
    "doc": "정렬",
    "title": "퀵 정렬의 복잡도",
    "content": "n*log(n) . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#%ED%80%B5-%EC%A0%95%EB%A0%AC%EC%9D%98-%EB%B3%B5%EC%9E%A1%EB%8F%84",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#퀵-정렬의-복잡도"
  },"198": {
    "doc": "정렬",
    "title": "기수 정렬 (Radix Sort)",
    "content": ". | 퀵정렬보다 좋지만, 메모리를 많이 사용한다! | 레코드를 아예 비교하지 않고, 정렬수행을 한다! | . ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#%EA%B8%B0%EC%88%98-%EC%A0%95%EB%A0%AC-radix-sort",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-13.html#기수-정렬-radix-sort"
  },"199": {
    "doc": "자료구조",
    "title": "자료구조",
    "content": ":pencil2: 자료구조 공부 기록장입니다. ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-menu.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-menu.html"
  },"200": {
    "doc": "코딩공부",
    "title": "코딩공부",
    "content": ":pencil2: 코딩 관련 공부 기록장입니다. ",
    "url": "http://localhost:4000/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80.html",
    "relUrl": "/docs/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80/%EC%BD%94%EB%94%A9%EA%B3%B5%EB%B6%80.html"
  },"201": {
    "doc": "탐색이란?",
    "title": "탐색이란?",
    "content": "## 탐색이란? 탐색: 여러개의 자료중 원하는 자료를 찾는 것이다! - 탐색키 : 항목과 항목을 비교해주는 key - 탐색을 위해 사용되는 자료구조는 **배열, 연결 리스트, 트리, 그래프 등**이 있다! 자료를 저장하는 방식으로 배열, 그리고 트리가 있는데, 이진 탐색은 정렬된 배열에서의 탐색이다. random access가 가능해야 이진 탐색이 가능하기 때문에 연결 리스트에서는 적용이 불가하다. 이진탐색의 원리는 다음과 같다. 배열의 중앙에 있는 값을 조사해서 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내서 탐색의 범위를 반으로 줄여가며 탐색을 하는 것이다. 이러한 이진 탐색의 원리는 이진탐색 트리에서도 적용된다. 이 점이 바로 그 둘의 공통점이 될 수 있겠다. 이진탐색 트리는 트리를 활용해 데이터를 저장하고 탐색하는 것으로, 이진탐색과 연결리스트를 결합한 자료구조이다. 이 점은 차이점이 될 수 있는데, '정렬된 배열'의 자료구조를 탐색하는 이진탐색과 다르게 이진탐색 트리는 '트리'를 활용한다는 점에 크게 다르다. 이진탐색 트리의 탐색 원리는 다음과 같다. 언급했듯이 이진탐색 트리에서도 좌, 우를 나누어 탐색하는데, 연결리스트가 적용된 자료구조이기 때문에 왼쪽 자식과 오른쪽 자식으로 나누어 탐색을 하게 된다. 12를 탐색하려고 할 때에, 18이 root node 이면 18보다 작은 12를 찾기 위해서 왼쪽 자식을 탐색한다. ## AVL 트리 AVL 트리는 모든 노드의 왼쪽과 오른쪽 서브 트리의 높이 차가 1 이하인 이진 탐색 트리이다. 트리가 비균형 상태가 되면, 노드들을 재배치하여 균형 상태가 유지되도록 만든다. 즉, 모든 노드의 균형 인수가 +1~-1이하이면 AVL트리라고 판단한다. 이렇게 균형잡힌 이진 탐색 트리를 AVL 트리라고 부르는데, 이렇게 균형잡히게 되면, 다양한 변수가 있을 수 있는 이진탐색트리에 비해서 탐색속도가 빠르다는 것이 장점이된다. 예를 들어 수업 앞부분에서 교수님께서 이진탐색트리의 성능에 대해 설명하신 부분이 있다. 이진탐색트리의 성능분석에서, 최악의 경우는 한쪽으로 치우친 경사이진트리의 경우이고, 최선의 경우는 이진 트리가 균형적으로 생성되어 있는 경우이다. 즉, AVL 트리는 이진탐색 트리의 최선의 경우만을 생각하게 해주는 트리인 것이다. 이러한 빠른 탐색속도를 자랑하는 AVL 트리의 시간복잡도는 항상 O(logn)이 된다. 탐색 연산은 이진 탐색 트리와 동일하다. 그리고 삽입 연산과 삭제 연산시에 균형상태가 깨질 수 있다. ",
    "url": "http://localhost:4000/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-14.html",
    "relUrl": "/docs/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-14.html"
  }
}
